<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="pkgstatsAnalyses">
<title>Historical Trends in R Package Structure and Interdependency on CRAN • pkgstatsAnalyses</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Historical Trends in R Package Structure and Interdependency on CRAN">
<meta property="og:description" content="pkgstatsAnalyses">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">pkgstatsAnalyses</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.1.132</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-2">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../articles/index.html">Articles</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/mpadge/pkgstats-analyses/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">
<script src="pkgstats_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <main id="main"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Historical Trends in R Package Structure and Interdependency on CRAN</h1>
                        <h4 data-toc-skip class="author">Mark Padgham &amp; Noam Ross</h4>
            
            <h4 data-toc-skip class="date">2022-01-13</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mpadge/pkgstats-analyses/blob/HEAD/vignettes/pkgstats.Rmd" class="external-link"><code>vignettes/pkgstats.Rmd</code></a></small>
      <div class="d-none name"><code>pkgstats.Rmd</code></div>
    </div>

    
    
<div class="section level1">
<h1 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h1>
<p>A key component of the success of Open Source Software (OSS) is package managers <span class="citation">(Ovens 2018)</span>, which effectively serve as curated repositories of independently-contributed software. Package managers exist both for specific operating systems <span class="citation">(Ovens 2018)</span> and specific computer languages such as python <span class="citation">(Harihareswara 2018)</span>, LaTeX <span class="citation">(“CTAN” 2021)</span>, JavaScript <span class="citation">(Goldwater 2020)</span>, and many others. This work analyses all current and historically archived packages in the CRAN (Comprehensive R Archive Network) package manager for the R language.</p>
<p>The majority of prior work on the temporal development or evolution of software has been based on individual pieces of software, here generically referred to as “packages”. One notably exception is a recent analysis of the “pypi” (Python Package Index) package manager for python <span class="citation">(Bommarito and Bommarito 2019)</span>, which analysed and presented a number of statistics relevant to the present work, including:</p>
<ul>
<li>Compound annual growth rates in numbers of new packages were slightly less (at 43%) than growth in active packages (47%) and in new releases (51%). these, at 39%.</li>
<li>Each package has around 7 +/- 19 new releases per year, at an average inter-release frequency of 65 +/ 144 days.</li>
<li>Total numbers of imported packages increases with compound annual growth rate of 62%.</li>
<li>The standard python libraries represent around 19% of all package imports.</li>
</ul>
<p>This analyses represents the most comprehensive analysis to date of a package manager for any computer language, drawn almost two million releases of 179,000 packages. The size of pypi necessarily restricted these analyses to package metadata, although single metrics of package size were also included. Moreover, the size of pypi meant that analyses of dependency networks were also relatively restricted to aggregate statistics only, with no analyses of the internal properties of dependency networks themselves.</p>
<p>More detailed considerations of temporal development and evolution of code have largely been restricted to individual packages. Analyses of code evolution frequently refer to work of <span class="citation">Lehman et al. (1997)</span>, who expressed their findings as a series of “laws” of software evolution. These “laws” include that, over time, software increases both in complexity and in functional content (or numbers of “modules”). Those laws of growth themselves derive from <span class="citation">Turski (1996)</span>, who posited an inverse-square law for software growth, later formalised in <span class="citation">Turski (2002)</span>.</p>
<p>This inverse-square “law” was nevertheless an empirical fitting exercise only, and merely posits the arguably simplest form for a process in which the rate of growth of a system decreases as the system grows. There is no theoretical reasons why software evolution should follow such a trajectory, nor do there appear to have been either any examinations of alternative models of growth, or of plausible theoretical foundations for any particular model.</p>
<p>These “laws” of software evolution have nevertheless been frequently used and cited (see overview in <span class="citation">Mens (2008)</span>, and references therein), although overwhelmingly for considerations of individual software packages. They have been widely adopted in a burgeoning field of what might be referred to as “Software Mining and Analytics”, particularly to elucidate useful predictors of software quality. A useful overview of the field was provided by <span class="citation">Allamanis and Sutton (2013)</span>, who usefully identified a number of categories, including that of “code statistics” examined here.</p>
<p>More detailed considerations of package dependency networks have been developed in more restricted, and thus more manageable, contexts, such as the analysis of the Debian network of <span class="citation">Gonzalez-Barahona et al. (n.d.)</span>, which revealed progressive increases in package inter-dependencies. Although they observe increases in the sizes of packages over time, and claim that this reflects the laws of <span class="citation">Lehman et al. (1997)</span>, they neither quantify nor model actual rates of change. <!-- do we or do we plan to? --> They also observe that the relative sizes of packages, measured in terms of lines of code, remains relatively stable across releases.</p>
<p>A more extensive consideration of dependency networks alone was provided by <span class="citation">Decan, Mens, and Grosjean (2019)</span>, who examined networks from seven package management systems, including pypi and CRAN. They observe that both numbers of packages and numbers of dependencies increase more slowly for CRAN packages than for any of the other systems they consider, as do numbers of package updates. They also observe that the “survival probability” (that a package is not updated at some time, <span class="math inline">\(t\)</span>) <!-- This seems to be reversed? --> is far greater for CRAN than for other package ecosystems (although with differences observed between packages which are not required by other packages, and those which are). Finally, they observe that the Gini coefficient of inequality between dependent packages has also increased over time in all systems.</p>
<p>This work focusses on the CRAN package system which is around one tenth the size of pypi for the python language, although still amounting to over 100,000 releases of around 20,000 packages. This smaller sizes enables far more detailed analyses than previous work, not just of package metadata, but also extending to detailed analyses of the code itself.</p>
<p>First, we describe the <code>{pkgstats}</code> R package, which can be used to generate and analyze properties of R package code, and the accompanying database of code statistics of all historical CRAN packages. We then describe trends in CRAN R package properties over the history of the archive (199X-2021). We focus on trends in four areas: Package metadata (licenses, authorship, translation), Package and content (file and function types and sizes), intra-package code structure (function call networks), and finally, dependency networks amongst packages. Finally, we discuss implications and likely drivers of these trends, and potential further applications and extensions of the <code>pkgstats</code> package and database.</p>
</div>
<div class="section level1">
<h1 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a>
</h1>
<!-- This section should be way longer. It shoule
- described pkgstats package in more detail, to the point of basic usage
- describe the different metrics collected - if not a full list, then at least
  categories and a reference to a full list
- describe the usage of `ctags` and generation of relevant network statistics
- describe the availability of the full package database and where to download
  it
-->
<p>Data in this study were generated by the <a href="https://docs.ropensci.org/pkgstats/" class="external-link">the R package, <code>pkgstats</code></a>, which we developed to quantify the structure and content of R packages using static code analysis techniques <span class="citation">(Papamichail, Diamantopoulos, and Symeonidis 2016)</span>. That package <a href="https://docs.ropensci.org/pkgstats/reference/pkgstats_from_archive.html" class="external-link">includes a function, <code>pkgstats_from_archive</code></a>, which can be applied to a local mirror of the CRAN archive to collate statistics from all packages. This methodological description begins with an overview of data sources used, followed by a description of two open-source libraries for “code tagging” used in the <code>pkgstats</code> package. We then describe the package itself, before providing details of statistical analyses.</p>
<div class="section level2">
<h2 id="data-r-packages-and-the-cran-server">Data: R packages and the CRAN server<a class="anchor" aria-label="anchor" href="#data-r-packages-and-the-cran-server"></a>
</h2>
<p>Our primary data source comprised every version of every R package hosted on the “Comprehensive R Archive Network” or CRAN, which is the centralised distribution system for R packages. The <code>R</code> language itself is defined by a single “package” referred to as “base R”. By default, all installations of <code>R</code> also <a href="https://github.com/wch/r-source/tree/trunk/src/library" class="external-link">include a suite of “recommended” packages</a>. All other packages are referred to as “Contributed Packages”. A number of the following results distinguish between base, recommended, and contributed code or packages.</p>
<p>CRAN currently holds close to 19,000 contributed packages, and also maintains a complete archive of all previous versions of all packages, including of archived packages no longer available on CRAN. The data analysed here were generated from a local mirror of the entire CRAN repository, including all current and archived packages, and amounting to around 105,000 packages (for an average of slightly over 5 releases per package). The raw data for these analyses are the contributed packages themselves. While relationships to objects (functions) in the base and contributed packages are considered, the structure of the base and recommended packages is not analysed here.</p>
<p>All R packages accord with the structure defined in the <a href="https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages" class="external-link">“<em>Writing R Extensions</em>” Manual</a>. Many aspects of the following analyses were applied to different components of R packages, in particular the following main sub-directories:</p>
<ul>
<li>The <code>/R</code> directory which holds all source files in the R language;</li>
<li>The <code>/src</code> directory which holds all code in other languages which needs to be compiled on package installation;</li>
<li>The <code>/inst</code> directory which generally holds bundles of external code, but may also include code used for cross-linking in compilation, including of other packages. Cross-linked code must be in an <code>/inst/include</code> sub-directory (as explained in <a href="https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages" class="external-link">this section of the “<em>Writing R Extensions</em>” Manual</a>). All of the following analyses only consider the <code>/inst/include</code> directory, and all references to the <code>/inst</code> directory imply this sub-directory only. Analyses excluded all other sub-directories within the <code>/inst</code> directory.</li>
<li>The <code>/vignettes</code> directory which includes extended documentation. (Such documentation may also be placed in an <code>/inst/doc</code> folder, but this was ignored here.)</li>
<li>The <code>/tests</code> directory containing test files.</li>
<li>The <code>/data</code> directory containing data files used to implement or demonstrate package functionality.</li>
</ul>
<p>The results which follow also distinguish between the two main kinds of R functions:</p>
<ul>
<li>Exported functions intended to be called by users of a package.</li>
<li>Non-exported functions intended only to be called internally by other functions of a package.</li>
</ul>
</div>
<div class="section level2">
<h2 id="code-tagging-with-ctags-and-gtags">Code tagging with “ctags” and “gtags”<a class="anchor" aria-label="anchor" href="#code-tagging-with-ctags-and-gtags"></a>
</h2>
<p>The <code>pkgstats</code> package is a static code analysis tool specifically developed for R packages, with much of the functionality extending from two general static analysis tools. Static code analysis tools generally work by constructing parse trees which relate a grammar describing one or more computer languages to each expression encountered by tracing the code. An important first step is to “tag” each expression, identifying the kind of expression and its scope (generally its membership either of some component of the underlying grammar, or some more local scope such as definitions within locally-sourced files).</p>
<p>The <code>pkgstats</code> package uses two open-source libraries for code tagging and parse tree construction: “ctags” and “gtags”. The original “ctags” library is no longer maintained, and these analyses used a maintained version called <a href="https://ctags.io" class="external-link">“Universal ctags”</a> which,</p>
<blockquote>
<p>generates an index (or tag) file of language objects found in source files for programming languages.</p>
</blockquote>
<p>This library was used here to tag each expression in the <code>R</code>, <code>src</code>, and <code>inst/include</code> directories, providing the following data for each tagged item:</p>
<ol style="list-style-type: decimal">
<li>The tag itself, such as the name of a function, variable, or other object;</li>
<li>The name of the corresponding file;</li>
<li>The full content of the expression in which that tag was used (as a text string);</li>
<li>The kind of object (in <code>R</code> files, generally a <code>function</code>, <code>functionVar</code> or variable defined within a function, <code>globalVar</code> for global variables, or other objects defined by the <code>R</code> language; kinds of objects can be arbitrarily diverse in other languages);</li>
<li>The computer language in which that object was referenced; and</li>
<li>The start and end line numbers of the file in which that object is defined or referenced.</li>
</ol>
<p>The “ctags” data for R files were also used to construct an “external call network” of references to all R functions in all packages, including the package being analysed, the base and recommended packages, and all other contributed packages imported by each package. Functions were attributed to packages by matching function names. Function names in R do not have to be unique, and “namespace conflicts” may arise between packages implementing different functions with the same name. We presumed that namespace conflicts most commonly arise in re-definitions of functions initially defined in base or recommended packages, and in all such cases we attributed a function to the external or contributed package over base or recommended definitions.</p>
<p>The “gtags” library, itself part of the <a href="https://www.gnu.org/software/global/" class="external-link">GNU Global library</a>, generates entries for every expression, with the “tag” itself defining the environment for that expression. This enables mappings to be made between every expression and its corresponding tag. We used “gtags” to construct object reference networks across all computer languages used in R packages (such as C, C++, or Python), to enable the construction of “function call networks” within and between all languages. While the terms “functions” and “calls” may not be appropriate for all computer languages and/or classes or types of objects, they nevertheless reflect the functionality of R code, and so are preferred here, even when referring to other object relationships such as class inheritance mechanisms.</p>
<p>It is possible to cross-compile “gtags” with “ctags”, to enable “gtags” to use the more expansive language parsing abilities of “ctags”, and to greatly extend the range of languages able to be parsed by “gtags”. In particular, “gtags” does not not by default parse R code, yet does so when cross-compiled with Universal “ctags”. Cross-compiled installations of “gtags” are, however, generally several times slower than simpler installations, and so these analyses did not use a cross-compiled version. While this meant restricting analyses to a smaller subset of potential languages, the output of “ctags” itself nevertheless describes tags in all possible languages, with “gtags” only used to map function call networks in languages other than R. Function-call networks within R were extracted from the “ctags” output as described above, and one additional function was written to link calls within R code as defined by the “ctags” output to external objects defined in other languages and specified by the “gtags” output. This enabled full function-call networks to be constructed within and between different languages used in R packages. Several properties of these networks were analysed as described below.</p>
<p>Data generated by “ctags” and “gtags” which were analysed here included:</p>
<ul>
<li>Numbers of internal and external functions in R.</li>
<li>Numbers and kinds of all objects in all other languages.</li>
<li>Numbers of Lines-of-Code for each function or object definition in each language.</li>
<li>References from each function (or object) make to all other functions (or objects), including references made to all functions defined in other base, recommended, or contributed R packages.</li>
</ul>
</div>
<div class="section level2">
<h2 id="the-pkgstats-package">The <code>pkgstats</code> package<a class="anchor" aria-label="anchor" href="#the-pkgstats-package"></a>
</h2>
<p>This sub-section describes additional data generated by <code>pkgstats</code> beyond that extracted from “ctags” and “gtags”. The full list of all data generated by the package is given in <a href="https://docs.ropensci.org/pkgstats/" class="external-link">the online documentation</a>, with this sub-section only describing those aspects which were analysed here.</p>
<div class="section level3">
<h3 id="description-files">‘DESCRIPTION’ files<a class="anchor" aria-label="anchor" href="#description-files"></a>
</h3>
<p>All R packages must include a <a href="https://www.debian.org/doc/debian-policy/ch-controlfields.html" class="external-link">Debian Control File</a> (“DCF”) called “DESCRIPTION” which contains a subset of standard DCF fields, including <a href="https://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file" class="external-link">a number of standardised and mandatory fields</a> able to be analysed here. We extracted:</p>
<ul>
<li>Numbers of authors (as individuals with a specified role of “aut”);</li>
<li>Numbers of contributors (as individuals with a specified role of “ctb”);</li>
<li>Full entries of the “License” field specifying the type of license under which the software was released; and</li>
<li>Entries in the “URL” field specifying one or more Uniform Resource Locators (URLs) for the package.</li>
<li>Lists of all imported packages used to construct dependency networks between packages. (Neither required nor suggested packages were considered here.)</li>
</ul>
</div>
<div class="section level3">
<h3 id="translation-files">Translation files<a class="anchor" aria-label="anchor" href="#translation-files"></a>
</h3>
<p>R packages may include <a href="https://cran.r-project.org/doc/manuals/R-exts.html#Preparing-translations" class="external-link">files used to translate all messages issued by code into other (human) languages</a>. These files are placed in a dedicated <code>/po</code> sub-directory, with file names prefixed with standard prefixes (generally, but not necessarily, <a href="https://en.wikipedia.org/wiki/ISO_639-1" class="external-link">ISO 639-1 codes</a>). This format enables translations to be readily identified and extracted. <code>pkgstats</code> extracts a list of all translations provided for each package.</p>
</div>
<div class="section level3">
<h3 id="lines-of-code-loc">Lines of Code (LoC)<a class="anchor" aria-label="anchor" href="#lines-of-code-loc"></a>
</h3>
<p><code>pkgstats</code> includes its own internal tool (coded in C++) for analysing Lines-of-Code (Loc). This tool produces output similar to many common LoC tools, with additional data on:</p>
<ol style="list-style-type: decimal">
<li>Total numbers of code, comment, and blank lines;</li>
<li>Total numbers of characters in code lines, along with total numbers of white-space characters, to enable metrics of proportional white space; and</li>
<li>Code indentation, including identification of tab-indentation.</li>
</ol>
</div>
<div class="section level3">
<h3 id="function-level-analyses">Function-level analyses<a class="anchor" aria-label="anchor" href="#function-level-analyses"></a>
</h3>
<p>The “ctags” and “gtags” output described above provides data on the start and end points of each function definition, along with names of associated files. These data were used to provide estimates of average LoC per function, and numbers of function definitions per file. (Where, as explained above, “function” is used here as generic label for any object in any language, such as class definitions.)</p>
<p>Each exported function in an R package must have a corresponding documentation file in the <code>/man</code> directory of the package with the suffix, <code>.Rd</code> for “R documentation”. <code>pkgstats</code> also statically parses these files with <a href="https://stat.ethz.ch/R-manual/R-devel/library/tools/html/parse_Rd.html" class="external-link">the <code>parse_Rd</code> function of the recommended <code>tools</code> package</a>. For the present analyses, this enabled identification of the number of parameters for each function, and the number of documentation characters for each parameter. Total length of documentation for each function was also quantified as the number of lines in the output produced by converting the result of <code>parse_Rd</code> to text (via the <code><a href="https://rdrr.io/r/tools/Rd2HTML.html" class="external-link">tools::Rd2txt</a></code> function).</p>
</div>
</div>
<div class="section level2">
<h2 id="network-analyses">Network Analyses<a class="anchor" aria-label="anchor" href="#network-analyses"></a>
</h2>
<p>Two distinct kinds of network analysis were performed here: <em>inter-package</em> analyses of dependency networks between packages (akin to <span class="citation">Decan, Mens, and Grosjean (2019)</span>), and <em>intra-package</em> analyses of the function call networks extracted from the “ctags” and “gtags” data described above.</p>
<div class="section level3">
<h3 id="inter-package-network-analyses">Inter-Package Network Analyses<a class="anchor" aria-label="anchor" href="#inter-package-network-analyses"></a>
</h3>
<p>The ‘DESCRIPTION’ files of R packages must specify all external packages which a package imports. These data can be used to construct a full dependency network of all packages. The results below present the following measures derived from package dependency networks, all of which were calculated with the <code>igraph</code> package <span class="citation">(Csardi and Nepusz 2006)</span>.</p>
<ol style="list-style-type: decimal">
<li>Numbers of packages which are not imported by any others - the terminal vertices in a dependency network;</li>
<li>Average “in-degree” of network vertices, or average numbers of times each package is imported by others;</li>
<li>The average <em>betweenness centrality</em> of each edge, which is the number of times that edge is traversed in connecting every package to every other package in the network;</li>
<li>The network-level <em>degree centrality</em>, which is a measure of vertex degree standardised to the overall size and structure of the network (<span class="citation">Freeman (1978)</span>).</li>
<li>A measure of the overall “size” of the network as the average distance between all pairs of vertices.</li>
</ol>
<p>Betweenness centrality provides insight into how centralised the network is, with higher values reflecting networks in which connections frequently traverse a common, central region. The network-level degree centrality reflects the extent to which vertices all have a relatively high in-degree; networks in which all networks have an equal in-degree have no effective centre, and so have a degree centrality of zero. In contrast, networks with a few highly-connected central vertices and many vertices with low in-degree will have a high degree centrality. These two centrality metrics provide slightly different insights: betweenness centrality will increase to the extent to which a network manifests a single, common centre; degree centrality will increase to the extent that networks become more centralised in general, regardless of whether or not any singly identifiable centre forms.</p>
<p>Networks with low degree centrality are readily traversable, and so will generally have lower average distances between all pairs of vertices. The distance metric nevertheless may offer additional insight, and will for example be higher independent of degree centrality for networks with extended peripheral connections. Finally, we note that clusters or local network communities were not considered here, as the dependency networks of CRAN packages are almost always so highly connected that the largest connected cluster represents over 99% of the network.</p>
</div>
<div class="section level3">
<h3 id="intra-package-network-analyses">Intra-Package Network Analyses<a class="anchor" aria-label="anchor" href="#intra-package-network-analyses"></a>
</h3>
<p>Intra-package networks were constructed from the function call networks described above, and included overall package networks connecting code in all sub-directories, as well as network analyses of only those components representing individual sub-directories, here constrained to network analyses of both <code>/R</code> and <code>/src</code> code. Function call networks within individual packages are commonly structured in several distinct clusters, and thus numbers of clusters provided an important first metric for intra-package analyses. Intra-package analyses considered the following metrics:</p>
<ol style="list-style-type: decimal">
<li>Ratio of numbers of edges to numbers of vertices.</li>
<li>Numbers of distinct clusters between all functions or objects across all languages.</li>
<li>The betweenness centrality of the function call network.</li>
<li>Numbers of terminal vertices (functions which do not call any other functions).</li>
<li>The average vertex degree.</li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="coupling-instability">Coupling Instability<a class="anchor" aria-label="anchor" href="#coupling-instability"></a>
</h2>
<p><a href="https://en.wikipedia.org/wiki/Software_package_metrics" class="external-link">Coupling Instability</a> is an important concept in the analysis of software dependency networks <span class="citation">(Martin 2003)</span>, and depends in turn on numbers of so-called <em>afferent</em> and <em>efferent</em> couplings. For any given packages, these are defined as:</p>
<ul>
<li>
<em>Afferent Couplings</em> as numbers of functions in other packages which depend on functions within the package.</li>
<li>
<em>Efferent Couplings</em> as numbers of functions from other packages which the package depends on.</li>
</ul>
<p><em>Afferent</em> couplings are numbers of <em>inbound</em> edges from all other packages to a given package, while <em>efferent</em> couplings are <em>outbound</em> edges coupling that package with all other packages. Respectively denoting afferent and efferent couplings by <span class="math inline">\(n_a\)</span> and <span class="math inline">\(n_e\)</span>, the coupling instability, <span class="math inline">\(I\)</span>, is then defined as <span class="math inline">\(I = n_e / (n_e + n_a)\)</span>. Packages which depend on many external calls (high efferent couplings), yet upon which few other packages depend (low afferent couplings) thus have a high coupling instability, while packages upon which many other packages depend, yet which themselves depend on few other packages have a low coupling instability. The analyses below quantified coupling instability for each package from the dependency networks, using total numbers of function calls between all packages, in order to estimate the average coupling instability of the entire network.</p>
</div>
<div class="section level2">
<h2 id="statistical-analyses">Statistical Analyses<a class="anchor" aria-label="anchor" href="#statistical-analyses"></a>
</h2>
<p>The following results depict and interpret qualitative trends and patterns, without reporting on any statistical tests. In frequentist terms, data were sufficiently large (<span class="math inline">\(N &gt; 105,000\)</span>) to ensure that all of the reported results, were they to be analyses as linear relationships, were entirely significant. There are two further important aspects to note in regard to statistical analyses detailed below.</p>
<div class="section level3">
<h3 id="temporal-analyses">Temporal Analyses<a class="anchor" aria-label="anchor" href="#temporal-analyses"></a>
</h3>
<p>Most of the following results depict the evolution of CRAN software over time, in two main ways:</p>
<ol style="list-style-type: decimal">
<li>As annual developments averaged over all packages; or</li>
<li>As developments for individual packages over sequences of releases.</li>
</ol>
<p>Several of the following results are divided into the corresponding sub-sections of “Annual Developments” and “Sequential Releases,” respectively referring to these two modes of analysis. Annual developments aggregate values over all packages for each year, while sequential developments aggregate values over each sequential release, so that the first versions of all packages are aggregated for a release sequence of one, second versions for release sequence two, and so on.</p>
<p>For continuously updated repositories like CRAN, annual developments can be captured in the following two primary ways:</p>
<ol style="list-style-type: decimal">
<li>Through considering each year to represent the state of CRAN at that time, and thus to include latests releases of all packages for that year, regardless of how long ago a package may previously have been updated. Annual estimates derived this way are referred to here as <strong>CRAN snapshots</strong>.</li>
<li>Through considering each year to represent only the state of CRAN in terms of packages uploaded in that specific year, disregarding any packages uploaded in prior years. Estimates derived this way are referred to simply as <strong>annual</strong> values.</li>
</ol>
<p>Under the plausible assumption that rates of package updates follow some kind of Poisson-like process, the ages of packages at any given time will be exponentially distributed, analogous to distributions of waiting times for Poisson processes. This means that values derived using <strong>CRAN snapshots</strong> will generally reflect exponentially-smoothed versions of <strong>annual</strong> values. Many of the graphical results which follow depict results dervied using both of these approaches, in which:</p>
<ul>
<li>solid lines represent annual values, which are generally noiser versions of</li>
<li>dashed lines, which represent effectively exponentially-smoothed versions of the same data using CRAN snapshots for each year.</li>
</ul>
<p>Where no additional interpretations are given, solid lines in all of the results that follow represent annual values, while dashed lines represent results derived from CRAN shapshots. See Fig. 1A immediately below, for an example. Where also not otherwise mentioned, all reported values refer to annual values, and not to values derived from CRAN snapshots.</p>
</div>
<div class="section level3">
<h3 id="distributional-properties-and-mean-values">Distributional properties and mean values<a class="anchor" aria-label="anchor" href="#distributional-properties-and-mean-values"></a>
</h3>
<p>Almost all statistics described above, and presented in the results below, were approximately log-normally distributed. References in any of the following results to mean values thus imply values calculated as <code>10^mean(log10(x))</code>. The use of direct mean values did not generally alter any of the qualitative conclusions which follow, yet resulted in many cases in less distinct or smooth trajectories or results.</p>
</div>
</div>
</div>
<div class="section level1">
<h1 id="results">Results<a class="anchor" aria-label="anchor" href="#results"></a>
</h1>
<div class="section level2">
<h2 id="metadata">Metadata<a class="anchor" aria-label="anchor" href="#metadata"></a>
</h2>
<p>The relatively regulated process of CRAN submissions <span class="citation">(Decan, Mens, and Grosjean 2019)</span> is reflected in more regulated meta-data able to be extracted from package ‘DESCRIPTION’ files. Numbers of both authors and contributors have increased over time (Fig. 1A), with contributors having been rarely acknowledged at all prior to 2010 (two years after the launch of GitHub), increasing to an average of one acknowledged contributor per package in 2021.</p>
<p>Numbers of unique licenses primarily reflect numbers of ways of declaring licenses, rather than actual numbers of licenses. Figure 1B shows a roughly linear increase in license declarations up to around 2007, followed by a pronounced drop and progression into a roughly stable range of somewhere over 50 distinct entries. The different ways of specifying the three versions of GPL licenses have accounted for over 83% of all CRAN packages, with the second most common type license being MIT, at 9.6%, followed by BSD at 2.0%. One of these three licenses are used in 95% of all CRAN packages.</p>
<div class="figure">
<img src="figures/fig01.png" alt=""><p class="caption"><strong>Figure 1.</strong> Annual developments of metadata from package ‘DESCRIPTION’ files.</p>
</div>
<p>The practice of translating messages within R packages into other languages has steadily declined in recent years (Fig. 2A), suggesting a pronounced increase in acceptance over the last 15 or so years of English as a globally standard language, and a concomitant decrease in active acknowledgement of other languages. (The <code>en@quot</code> translation entry is described in the <a href="https://cran.r-project.org/doc/manuals/R-admin.html#Localization-of-messages" class="external-link"><em>R Installation and Administration</em> Manual</a> as a translation which, “can be used in a UTF-8 locale to have American error messages with pairs of single quotes translated to Unicode directional quotes.”) Rates of decrease since 2008 equate to 1.5% fewer packages per year including translations, from a total of just over 20% of all packages in 2008, to barely over 1% in 2021. While rates of decrease have slowed somewhat in recent years, extrapolation of the preceding five years nevertheless suggests that the practice of offering translations will entirely disappear by 2023.</p>
<div class="figure">
<img src="figures/fig02.png" alt=""><p class="caption"><strong>Figure 2.</strong> (A) Annual frequencies of the top 10 translations. (B) Annual frequencies of the top 10 primary URL domains, with frequencies for GitHub divided by 20.</p>
</div>
<p>Analyses of URLs provided in package ‘DESCRIPTION’ files clearly reveal an abrupt break after around 2010 with the advent of online code repositories (Fig. 2B). GitHub has always dominated, while r-forge has declined progressively since around 2015. The most notable increase has been the emergence of rOpenSci as provider of the only URL to come close to within 1/20th of the popularity of GitHub over the past few years.</p>
</div>
<div class="section level2">
<h2 id="package-structure-and-content">Package Structure and Content<a class="anchor" aria-label="anchor" href="#package-structure-and-content"></a>
</h2>
<p>The temporal development of numbers of files manifest several notable characteristics (Figure 3). Unsurprisingly, R packages have always been dominated by files in the <code>R/</code> directory, numbers of which increased considerably up to around 2010, after which they have generally stabilised at mean values of around 13-15 files (Fig. 3A). The <code>vignettes</code> directory is the only place within R packages in which numbers of files have remained relatively constant over the preceding 20+ years. Packages generally had very few files in the <code>inst</code> directory prior to 2010, after which they increased until around 2015, before decreasing again more recently. The two sub-directories in which numbers of files have increased most significantly are <code>src</code> and <code>tests</code>, with the latter increase particularly distinct, clearly indicating that packages have become progressively better tested.</p>
<div class="figure">
<img src="figures/fig03.png" alt=""><p class="caption"><strong>Figure 3</strong> (A) Number of files in different diretories per year (with legend in panel B). Solid lines represent loess-smoothed interpolations, while dashed lines are raw annual values (not CRAN snapshots). (B) Proportional increases in numbers of files per release.</p>
</div>
<p>Figure 3B shows equivalent relative changes within individual packages across successive releases. That panel depicts proportional changes in numbers of files in each of the nominated directories, starting with the change between the second and first release (a “Release sequence” of 2). Although numbers of files generally increase with each new release, <em>rates</em> of increase tend to slow down, with packages approaching stability (a ratio of 1) after around 20 releases. Throughout these first 20 releases, numbers of test files generally increase at a greater rate than numbers of files in any other directory, further indicating that not only have packages become better tested over time on average (Fig. 2A), but that individual packages tend to become better tested with each successive release.</p>
</div>
<div class="section level2">
<h2 id="code-metrics">Code Metrics<a class="anchor" aria-label="anchor" href="#code-metrics"></a>
</h2>
<div class="section level3">
<h3 id="annual-developments">Annual Developments<a class="anchor" aria-label="anchor" href="#annual-developments"></a>
</h3>
<p>Figure 4 shows the temporal evolution of a number of code metrics. These figures distinguish between the two primary kinds of R functions, exported and non-exported, and also between the main sub-directories of R packages described at the outset. Lines of Code (“LoC”) in the primary <code>/R</code> and <code>/src</code> directories broadly increased up to around 2005-2010, after which time LoC in these directories has slightly decreased, converging on just over 600 lines in both <code>/R</code> and <code>/src</code> directories. These trends are broadly reflected in LoC per function (Fig. 4B), excepting the early years of CRAN, during which functions often had well over 100 lines each, especially <code>src</code> functions defined in other languages (in those years, primarily Fortran and C). LoC per function have remained broadly stable for almost 20 years, at around 30 lines for all function types and languages. The slight decrease discernible since around 2015 amounts to one LoC less for exported, non-exported, and <code>/src</code> functions every 3.4, 8.5, and 1.5 years, respectively.</p>
<p>Total numbers of R functions initially increased until around 2007, peaking at just under 30 exported and over 50 non-exported functions per package (Fig. 4C). Numbers of exported R functions have decreased since then to around 17 exported and 40-45 non-exported functions per package in 2021. Numbers of functions defined in <code>/src</code> directories have followed broadly similar trajectories to exported <code>/R</code> functions, slightly decreasing since the early 2000’s to between 30-40 functions. Numbers of functions per source file in both <code>/R</code> and <code>/src</code> directories have nevertheless progressively decreased since the early 2000’s to now amount to less than four <code>/R</code> functions and just over five <code>/src</code> functions per file (Fig. 4D).</p>
<div class="figure">
<img src="figures/fig04.png" alt=""><p class="caption"><strong>Fig. 4</strong> Development of code metrics per year.</p>
</div>
</div>
<div class="section level3">
<h3 id="sequential-releases">Sequential Releases<a class="anchor" aria-label="anchor" href="#sequential-releases"></a>
</h3>
<p>Figure 5 shows results equivalent to Fig. 4, but for the development of the respective metrics with each sequential release of a package, rather than being averaged over all packages for each year. Lines of code generally increase as packages mature, with mean numbers of lines in the <code>/R</code> directory increasing tenfold from under 400 for first releases to over 5,000 in packages with 100 or more releases. LoC in <code>/inst</code> directories also tend to increase as packages develop, although to a lesser extent, and only becoming notable after around 50 releases. Beyond the first few releases, there are always fewer LoC in <code>/src</code> directories than in <code>/R</code> directories. This contrasts with the annual aggregate results of Fig. 4A, which suggest more LoC in <code>/src</code> than <code>/R</code> directories until around 2007, and roughly equal numbers since then. This difference reflects the fact that most packages have only one or two releases (the distribution of numbers of releases is not shown here, but manifests a very smooth exponential decrease), so Fig. 4A is dominated by packages in a very early state of development, for which LoC in <code>/src</code> often exceed numbers in <code>/R</code>. The decrease in the later phases of package maturation, beyond around 50 releases, may reflect restructuring code from the <code>/src</code> to the <code>/inst</code> directories, in order to allow cross-compilation by other packages. This clear peak in LoC in <code>/src</code> directories may in turn suggest this is an approximate number of releases before other developers become aware of the functionality of package <code>/src</code> directories. The clearest result of Fig. 4A is manifest in total LoC, which increases in a strikingly linear manner even out to the 100th release of a package.</p>
<div class="figure">
<img src="figures/fig05.png" alt=""><p class="caption"><strong>Fig. 5</strong> Development of code metrics per release of each package.</p>
</div>
<p>These increases in LoC nevertheless corresponded to general decreases in LoC per function with increasing numbers of releases (Fig. 5B). Similar to the aggregate LoC measures of panel A, <code>/src</code> directories represent the only location where LoC manifest a distinct peak as packages matured, with LoC per <code>/src</code> function peaking slightly earlier (after around 40 releases) than total LoC (slightly over 50). In all directories, LoC per function either slightly increased or remained generally stable over the first 50 or so releases, beyond which functions in all directories clearly become considerably more streamlined, and LoC decreases markedly out to the 100th release. These decreases are nevertheless relatively minor, and amount to removing one LoC per function for every 5, 7, or 18 releases for exported R, non-exported R, or source functions, respectively.</p>
<p>The increasing total measures of LoC of panel A combined with decreasing LoC per function of panel B must mean that more functions are added as packages mature, which is precisely what Fig. 5C reveals. Packages initially contain less than ten exported functions on average, yet this increases over 10-fold to over 130 by the 100th release. Numbers of <code>/src</code> functions are initially higher, at around 20, and increase relatively less, to around 100 after 100 releases. Numbers of non-exported <code>/R</code> functions manifest the most pronounced increase, of over 15 times from 20 functions for initial releases, to well over 300 for the 100th release. Finally, numbers of functions per file show no clear trend for <code>src</code> code, remaining broadly stable at around six functions per file (Fig. 4D). In contrast, <code>/R</code> code files begin with 3-4 functions per file, and increase progressively to around eight functions per file after 100 releases, in the context of Figs. 4B-C clearly mostly due to breaking large non-exported functions down into multiple, smaller functions.</p>
<p>Finally, the numbers of functions depicted in Fig. 4C actually counts any arbitrary code objects in all languages contained in <code>/src</code> directories, and so corresponds directly to the “modules” posited to increase according to the inverse-square “law” of software evolution <span class="citation">(Turski 1996, 2002; Lehman et al. 1997)</span>. The defining qualitative feature of such inverse–square growth is an initially highly concave form, with rates decreasing notably as packages mature. The trajectories of Fig. 4C appear in contrast strikingly linear, all manifesting trajectories which would be very poorly described by such an inverse-square form.</p>
</div>
</div>
<div class="section level2">
<h2 id="package-imports-and-exports">Package Imports and Exports<a class="anchor" aria-label="anchor" href="#package-imports-and-exports"></a>
</h2>
<p>Like the “standard” libraries for the python language, R has a core set of “base” and “recommended” packages. The function call networks extracted by <code>pkgstats</code> enable counting numbers of calls to each of these groups of packages, as well as to “contributed” packages hosted on CRAN.</p>
<div class="section level3">
<h3 id="annual-developments-1">Annual Developments<a class="anchor" aria-label="anchor" href="#annual-developments-1"></a>
</h3>
<p>Figure 6A shows the change over time in proportions of calls to these three groups of packages, revealing a recent tendency (since around 2015) of fewer calls to base R functions, from over 80% of all function calls in the early 2000s, to below 70% in the previous two years. This decrease has been offset by greater numbers of calls to functions in contributed packages, while calls to recommended packages have remained generally stable at around 20%. Although calls to contributed packages have always represented the lowest proportion of these three groups, this recent increase nevertheless places them on almost equal proportion (at 12%) to calls to recommended packages (at 18%).</p>
<div class="figure">
<img src="figures/fig06.png" alt=""><p class="caption"><strong>Fig. 6</strong> Dependency networks between packages over time. (A) Proportions of function calls to the three categories of packages. (B) Coupling instability from package funciton calls. (C) Gini coefficients from both package dependency networks, and numbers of funciton calls. (D) Aggregate numbers of calls makde to the top ten imported packages.</p>
</div>
<p>Figure 6B shows the “coupling instability” of packages over time. As explained above, this is a measure of the extent to which packages depend on external functionality (efferent couplings) without other packages in turn depending on them (afferent couplings). Packages on CRAN were largely stable until around 2010, at a coupling instability of around 0.5, meaning numbers of functions from each package which were imported by other packages were roughly equal to numbers of external functions each package imported. Instability has increased markedly since that time, indicating that packages have become increasingly dependent on external functionality, while the average package is less likely to provide functionality used by other packages. The coupling instability over the preceding two years of around 80% implies that packages make on average eight calls to other packages for every two calls made to that package.</p>
<p>As another aggregate measure of changes in package imports, <span class="citation">Decan, Mens, and Grosjean (2019)</span> analysed Gini coefficients, which are standardised aggregate differences in numbers of imports between packages. Systems in which all packages import equal numbers of dependencies have a Gini coefficient of zero, while systems with maximally heterogeneous numbers of imports have a Gini coefficient of one. While they concluded that Gini coefficients have increased over time for all seven of the package distribution systems they studied (including CRAN), at least over their time period of 2012-2017, our equivalent results are depicted in Fig. 6C, revealing a profound dependence on how annual values are defined and calculated. Using “annual values” through aggregating statistics only from packages uploaded in each year (solid lines) yields Gini coefficients which decrease over time, while calculating annual values as “CRAN snapshots” as the entire system would have existed for each year (dashed lines) yields Gini coefficients which increase over time. Their results appear to qualitative accord with our “CRAN snapshot” values for package dependency networks, although our values are only around half of theirs, suggesting that they perhaps neglected a final divisor of 2 in their calculations.</p>
<p>Moreover, that panel depicts Gini coefficients calculated both from numbers of imported packages, and total numbers of external function calls. Numbers of function calls will only equal numbers of imported packages when only one function is used from each package, otherwise numbers of function calls must be greater, leading to larger Gini coefficients of inequality in numbers of external function calls between packages.</p>
<p>Finally, figure 6D depicts changes in numbers of unique function calls from each package to the top ten contributed packages, defined as the ten packages with the largest total number of unique function calls from all packages throughout the history of CRAN. The top two packages of {ggplot2} and {dplyr} account for 16.6% of all function calls from all contributed packages over the time shown. Numbers of function calls are shown on a logarithmic scale, with numbers of calls to each of these packages increasing exponentially between 2013 and 2018, before levelling off or even slightly decreasing.</p>
</div>
<div class="section level3">
<h3 id="sequential-releases-1">Sequential Releases<a class="anchor" aria-label="anchor" href="#sequential-releases-1"></a>
</h3>
<p>The first two panels of Figure 7 show results equivalent to Figs 6A-B, but for changes with progressive releases of each package. Proportions of calls to the three categories of packages (Fig. 6A) stay very similar across releases, and so Fig. 7A shows a slightly modified form quantifying proportional changes between successive releases. This reveals that values for both base and recommended packages remain above one out to around 30-40 releases, indicating that packages progressively decrease calls to contributed packages in favour of calls to base and recommended packages over the initial development phases. (Equivalent proportions of calls to recommended packages stay broadly constant, albeit with marked variability, and are not shown.) Beyond around 20-30 releases, relative rates of change approach the stable level of 1, and proportions to these three categories of packages remain relatively stable.</p>
<div class="figure">
<img src="figures/fig07.png" alt=""><p class="caption"><strong>Fig. 7</strong> Dependency networks between packages over sequential releases. (A) Proportional change in numbers of calls to base and recommended packages between successive releases. Solid lines show loess-smoothed interpolations, while dashed lines show raw values (and not values from cran snapshots). (B) Coupling instability. (C) Average numbers of functions from each package imported by other packages, and averge numbers of times packages are imported by other packages.</p>
</div>
<p>Figure 7B shows the average trajectory of coupling instability for individual packages across the depicted numbers of sequential releases, which decreases very progressively as packages mature, as should be expected if packages are increasingly likely to be imported by other packages (that is, afferent coupling should generally increase). That figure also shows average numbers of efferent couplings, or numbers of outward calls from each package to other packages, which stay largely stable as packages develop. Increases in package stability thus arise as packages develop purely through being imported as dependencies by increasing numbers of other packages. This in turn suggests that the best way to counteract the increasing coupling instability of CRAN as a whole depicted in Fig. 6B would be to ensure that packages remain progressively developed, rather than abandoned after only a few releases.</p>
<p>Finally, Fig. 7C shows progressions of both packages and individual functions being imported into other packages as a function of release sequence. The number of packages importing a package increases progressively with numbers of releases, as was already clear from Fig. 7B. Packages with less than ten releases are, on average, imported by very few other packages, while packages with 40 or more releases are imported by ten other packages on average. The second line on that figure nevertheless reveals that packages import on average only 1-2 functions from other packages, and that numbers of functions imported by other packages increase only marginally as packages mature.</p>
<p>Coupled with the observed increases in numbers of exported functions as packages mature depicted in Fig. 5C, the slight increase in numbers of functions imported by other packages nevertheless suggests a relationship between total numbers of functions exported by a package, and numbers imported by other packages. Indeed, taking only the latest versions of all packages and relating these two values reveals that other packages are likely to import one additional function on average for every 2.8 additional functions exported by that package.</p>
</div>
</div>
<div class="section level2">
<h2 id="network-analyses-1">Network Analyses<a class="anchor" aria-label="anchor" href="#network-analyses-1"></a>
</h2>
<div class="section level3">
<h3 id="annual-developments-2">Annual Developments<a class="anchor" aria-label="anchor" href="#annual-developments-2"></a>
</h3>
<p>The first two panels of Fig. 8 show the temporal development of the CRAN package dependency network, in both cases revealing that most network metrics have broadly stabilised over the preceding five or so years, and that variations were much more pronounced prior to around 2015. The proportion of terminal vertices, or packages not imported by any other packages, has remained broadly stable at around 55-60% of all packages. The mean vertex degree of the dependency network has nevertheless progressively increased, especially since 2015, indicating that those packages which are imported by others have been imported by increasing numbers of other packages.</p>
<!--

# dependency networks over time

-->
<div class="figure">
<img src="figures/fig08.png" alt=""><p class="caption"><strong>Figure 8</strong> Network metrics for (A-B) the CRAN dependency network, and (C-D) Function call networks within packages.</p>
</div>
<p>Such an increase in average numbers of imports must increase the overall connectivity of the dependency network, with Fig. 8B showing concomitant decreases in both centrality metrics over time. Average distances between each pair of packages in the network increased notably up to around 2013, after which time they have progressively decreased. Since numbers of terminal vertices have remained generally stable, while centrality has decreased, the initial increase in mean distance likely reflects terminal vertices becoming nevertheless further away, for example through the network evolving a number of distinct centres. The more recent decrease in mean distance may then reflect an equivalent centralisation of the dependency network.</p>
<p>The lower two panels of Fig. 8 depict the evolution of function call networks within individual packages. Fig. 8A shows the ratio of numbers of edges to numbers of vertices, with higher values indicating more densely connected networks. Since around 2005, network connections within R functions, whether exported or not, have remained largely constant, with each function being called by around 5-6 other functions. Connections between functions in <code>/src</code> directories have in contrast decreased considerably, with each <code>/src</code> function (or object) now being “called” (or referenced, inherited, or any other method) by just over one other function. Ratios of edges to vertices in the full function call network extending between all directories (including <code>/inst</code>) has progressively declined from over 4 calls per function to less than 3 in recent years. Function call networks form on average around three distinct clusters for each package, peaking at over 3.5 in 2007 before more recently decreasing to just over 2.5 clusters.</p>
<p>The final panel (Fig. 8D) shows average centrality metrics from function call networks, revealed a marked stability, except for numbers of terminal edges (in that context, meaning numbers of functions which call no other functions), which have decreased since around 2005 from around 12 per package to around 7.</p>
</div>
<div class="section level3">
<h3 id="sequential-releases-2">Sequential Releases<a class="anchor" aria-label="anchor" href="#sequential-releases-2"></a>
</h3>
<p>Analyses of sequential releases can only meaningfully be applied to the function call networks of Figs. 8C-D, and so Fig. 9 depicts equivalent values only for those two panels. Fig. 9A reveals that function call networks tend to become more densely connected as packages mature, and more so in <code>/src</code> than in <code>/R</code> directories. The aggregate increase contrasts strikingly with the equivalent and generally decreasing average tendency over time of Fig. 8C. This contrast can again be explained by the fact that most packages only have one or two releases, and so packages on CRAN have on average become less internally connected over time as recently-released packages have increasingly dominated. The decrease in package connectivity over one year of Fig. 8C corresponds to an equivalent increase in Fig. 9A after 224 releases, indicating that decreases in internal connectivity through increasing dominance of recently-released packages far outweighs compensatory decreases through packages maturing.</p>
<!--
Fig 8 but over package release instead of year
-->
<div class="figure">
<img src="figures/fig09.png" alt=""><p class="caption"><strong>Figure 9</strong> Network metrics from function call networks as a function of release sequence.</p>
</div>
<p>Finally, centrality metrics change dramatically as packages mature (Fig. 9B), in stark contrast to the annual changes of Fig. 8D. Packages develop greater numbers of terminal edges, yet retain almost identical vertex degrees through becoming more centralised as they develop. One way such an effect could be achieved would be through transforming a package from having several distinct clusters, each internally highly connected yet only loosely coupled to other clusters, progressing towards having fewer numbers of more highly centralised clusters, with increasing numbers of single connections out to terminal vertices.</p>
</div>
</div>
<div class="section level2">
<h2 id="code-formatting-and-documentation">Code formatting and Documentation<a class="anchor" aria-label="anchor" href="#code-formatting-and-documentation"></a>
</h2>
<p>We conclude these results with analyses generated by the internal Lines-of-Code routines of <code>pkgstats</code>, along with static analyses of the function documentation (<code>.Rd</code>) files. Proportions of blank and comment lines have remained markedly similar in both <code>/R</code> and <code>/src</code> directories over time, except for comment lines in <code>/R</code> code, which have increased dramatically since around 2010. This roughly corresponds to the first release of the {roxygen2} package which has indubitably done more than any other package to standardise documentation of R functions. This increase in <code>/R</code> documentation is likely a direct reflection of the widespread adoption of <code>roxygen2</code> as the documentation standard for R packages.</p>
<div class="figure">
<img src="figures/fig10.png" alt=""><p class="caption"><strong>Figure 10.</strong> Code formatting and documentation.</p>
</div>
<p>The relative proportion of white space in code lines has increased consistently yet very slightly over time, amount to an increase from slightly under 13% to slightly over 14.5%. The most dramatic development of Fig. 10B is clearly the decrease in the proportion of files with tab-indentation, from well over 60% before the year 2000 to barely over 10% today. Code indentation ignoring tabs increased until around 2005-2010, remaining constant at 3-3.5 spaces for many years before more recently declining to well under 3 spaces.</p>
<p>Each R function in 1998 had an average of six parameters, yet this declined very rapidly to under four within two years. Numbers of parameters have progressively increased since then, yet still barely exceeding an average of four parameters per function. Parameter documentation has followed an almost identical trend, increasing from under 70 characters per parameter to just over 80. In contrast, total numbers of documentation lines per function initially increased until around 2010, at almost 60 lines, before decreasing more recently to 50 lines per function or less.</p>
<p>Finally, the equivalent results analysed as a function of release sequence rather than year reveal that functions become markedly better documented as packages mature (Fig. 10D). Analogous to preceding results, the recent decrease in documentation lines per function likely reflects an increasing prevalence of recently released packages, while all packages uniformly expand function documentation as they mature, even though documentation of individual parameters does not greatly change.</p>
<p>Finally, contrasting panels C and D of Fig. 10 also reveals a likely influence of increasing dominance of recent packages on numbers of parameters per function. While this number has increased consistently over recent years (Fig. 10C), numbers of parameters also decrease markedly as packages mature, equating to an average of one parameter fewer in all functions after 58 releases. The equivalent annual effect from Fig. 10C would translate to one additional parameter every 46 years. The average interval between package releases over the duration of CRAN has been 207 days, according to which 58 releases would take 33 years. That comparison suggests that the effects of packages maturing in decreasing average numbers of parameters per function (still) slightly out-competes the counteracting effect of increasing average numbers of parameters per function through the increasing dominance of recently released packages.</p>
</div>
</div>
<div class="section level1">
<h1 id="discussion">Discussion<a class="anchor" aria-label="anchor" href="#discussion"></a>
</h1>
</div>
<div class="section level1 unnumbered">
<h1 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h1>
<div id="refs" class="references">
<div id="ref-mining-repos-2013">
<p>Allamanis, Miltiadis, and Charles Sutton. 2013. “Mining Source Code Repositories at Massive Scale Using Language Modeling.” In <em>2013 10th Working Conference on Mining Software Repositories</em>, 207–16. <a href="https://doi.org/10.1109/MSR.2013.6624029" class="external-link">https://doi.org/10.1109/MSR.2013.6624029</a>.</p>
</div>
<div id="ref-pypi2019">
<p>Bommarito, Ethan, and Michael Bommarito. 2019. “An Empirical Analysis of the Python Package Index (Pypi).” <em>arXiv</em> 1907.11073. <a href="http://arxiv.org/abs/1907.11073" class="external-link">http://arxiv.org/abs/1907.11073</a>.</p>
</div>
<div id="ref-igraph">
<p>Csardi, Gabor, and Tamas Nepusz. 2006. “The Igraph Software Package for Complex Network Research.” <em>InterJournal</em> Complex Systems: 1695. <a href="https://igraph.org" class="external-link">https://igraph.org</a>.</p>
</div>
<div id="ref-ctan-wiki">
<p>“CTAN.” 2021. <em>Wikipedia</em>. <a href="https://en.wikipedia.org/w/index.php?title=CTAN&amp;oldid=1049045588" class="external-link">https://en.wikipedia.org/w/index.php?title=CTAN&amp;oldid=1049045588</a>.</p>
</div>
<div id="ref-seven-pkg-networks-2019">
<p>Decan, Alexandre, Tom Mens, and Philippe Grosjean. 2019. “An Empirical Comparison of Dependency Network Evolution in Seven Software Packaging Ecosystems.” <em>Empirical Software Engineering</em> 24: 381–416. <a href="https://doi.org/10.1007/s10664-017-9589-y" class="external-link">https://doi.org/10.1007/s10664-017-9589-y</a>.</p>
</div>
<div id="ref-network-centrality-79">
<p>Freeman, Linton C. 1978. “Centrality in Social Networks Conceptual Clarification.” <em>Social Networks</em> 1 (3): 215–39. <a href="https://doi.org/https://doi.org/10.1016/0378-8733(78)90021-7" class="external-link">https://doi.org/https://doi.org/10.1016/0378-8733(78)90021-7</a>.</p>
</div>
<div id="ref-npm-2020">
<p>Goldwater, Matt. 2020. “An Abbreviated History of JavaScript Package Managers.” <em>Medium</em>. <a href="https://javascript.plainenglish.io/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e" class="external-link">https://javascript.plainenglish.io/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e</a>.</p>
</div>
<div id="ref-macro-evolution-2009">
<p>Gonzalez-Barahona, Jesus M., Gregorio Robles, Martin Michlmayr, Juan José Amor, and Daniel M. German. n.d. “Macro-Level Software Evolution: A Case Study of a Large Software Compilation.” <em>Empirical Software Engineering</em> 14 (3): 262–85. <a href="https://doi.org/10.1007/s10664-008-9100-x" class="external-link">https://doi.org/10.1007/s10664-008-9100-x</a>.</p>
</div>
<div id="ref-new-pypi-2018">
<p>Harihareswara, Sumana. 2018. “A New Package Index for Python [LWN.Net].” <em>A New Package Index for Python</em>. <a href="https://lwn.net/Articles/751458/" class="external-link">https://lwn.net/Articles/751458/</a>.</p>
</div>
<div id="ref-software-evolution-97">
<p>Lehman, M. M., J. F. Ramil, P. D. Wernick, D. E. Perry, and W. M. Turski. 1997. “Metrics and Laws of Software Evolution-the Nineties View.” In <em>Proceedings Fourth International Software Metrics Symposium</em>, 20–32. <a href="https://doi.org/10.1109/METRIC.1997.637156" class="external-link">https://doi.org/10.1109/METRIC.1997.637156</a>.</p>
</div>
<div id="ref-martin-agile-2002">
<p>Martin, Robert C. 2003. <em>Agile Software Development, Principles, Patterns, and Practices</em>. Upper Saddle River, N.J.: Prentice-Hall.</p>
</div>
<div id="ref-Mens2008">
<p>Mens, Tom. 2008. “Introduction and Roadmap: History and Challenges of Software Evolution.” In <em>Software Evolution</em>, 1–11. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="https://doi.org/10.1007/978-3-540-76440-3_1" class="external-link">https://doi.org/10.1007/978-3-540-76440-3_1</a>.</p>
</div>
<div id="ref-pkg-mngrs-2018">
<p>Ovens, Steve. 2018. “The Evolution of Package Managers.” <em>Opensource.com</em>. <a href="https://opensource.com/article/18/7/evolution-package-managers" class="external-link">https://opensource.com/article/18/7/evolution-package-managers</a>.</p>
</div>
<div id="ref-static-analysis-2016">
<p>Papamichail, Michail, Themistoklis Diamantopoulos, and Andreas Symeonidis. 2016. “User-Perceived Source Code Quality Estimation Based on Static Analysis Metrics.” In <em>2016 Ieee International Conference on Software Quality, Reliability and Security (Qrs)</em>, 100–107. <a href="https://doi.org/10.1109/QRS.2016.22" class="external-link">https://doi.org/10.1109/QRS.2016.22</a>.</p>
</div>
<div id="ref-Turski02">
<p>Turski, W. M. 2002. “The Reference Model for Smooth Growth of Software Systems Revisited.” <em>IEEE Transactions on Software Engineering</em> 28 (8): 814–15. <a href="https://doi.org/10.1109/TSE.2002.1027802" class="external-link">https://doi.org/10.1109/TSE.2002.1027802</a>.</p>
</div>
<div id="ref-Turski96">
<p>———. 1996. “Reference Model for Smooth Growth of Software Systems.” <em>IEEE Transactions on Software Engineering</em> 22 (08): 599–600. <a href="https://doi.org/10.1109/TSE.1996.10007" class="external-link">https://doi.org/10.1109/TSE.1996.10007</a>.</p>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Mark Padgham.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.1.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
