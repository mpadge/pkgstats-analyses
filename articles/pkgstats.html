<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="pkgstatsAnalyses">
<title>Historical Trends in R Package Structure and Interdependency on CRAN • pkgstatsAnalyses</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Historical Trends in R Package Structure and Interdependency on CRAN">
<meta property="og:description" content="pkgstatsAnalyses">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">pkgstatsAnalyses</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.1.159</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../articles/index.html">Articles</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/mpadge/pkgstats-analyses/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Historical Trends in R Package Structure and Interdependency on CRAN</h1>
                        <h4 data-toc-skip class="author">Mark Padgham &amp; Noam Ross</h4>
            
            <h4 data-toc-skip class="date">2022-02-01</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mpadge/pkgstats-analyses/blob/HEAD/vignettes/pkgstats.Rmd" class="external-link"><code>vignettes/pkgstats.Rmd</code></a></small>
      <div class="d-none name"><code>pkgstats.Rmd</code></div>
    </div>

    
    
<pre><code><span class="co">## Warning in register(): Can't find generic `scale_type` in package ggplot2 to</span>
<span class="co">## register S3 method.</span></code></pre>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>The temporal development of software has been studied for many decades, commonly through the development of individual pieces of software or, in rarer cases, comparative studies between a select few pieces of software <span class="citation">(see comprehensive literature reviews in Syeed, Hammouda, and Syatä 2013; Chahal and Saini 2016)</span>. Open source software in many languages is nevertheless increasingly dependent upon and therefore shaped by developments in other packages or libraries. Any computer language has associated with it an evolving ecosystem of software, and the evolution of any one component of that ecosystem is best studied in the context of the evolution of the ecosystem as a whole. In short, the development or evolution of open source software is better studied in <em>collective</em> rather than <em>individual</em> terms.</p>
<p>One focal point of historically individual studies on software evolution has been the work of <span class="citation">Lehman et al. (1997)</span>, who expressed their findings as a series of “laws” of software evolution. These “laws” include that, over time, software increases both in complexity and in functional content (or numbers of “modules”). Those laws of growth themselves derive from <span class="citation">Turski (1996)</span>, who posited an inverse-square law for software growth, later formalised in <span class="citation">Turski (2002)</span>, albeit as a purely empirical exercise absent any firm theoretical reasoning.</p>
<p>These “laws” of software evolution have nevertheless been frequently used and cited <span class="citation">(see overview in Mens 2008, and references therein)</span>, and have strongly influenced the development of a research field which might be referred to as “Software Mining and Analytics”, which has itself particularly focussed on elucidating useful predictors of software quality. A useful overview of the field was provided by <span class="citation">Allamanis and Sutton (2013)</span>, who empirically identified a number of research categories within this broad field, including one of “code statistics” which describes this present research.</p>
<p>For many computer languages, individual pieces of open-source software – hereafter referred to as “packages” – are held and distributed through centralised package distribution services <span class="citation">(Ovens 2018)</span>, which manifest forms of collective “evolution” above and beyond the evolution of individual packages. Package distribution services serve as curated repositories of independently-contributed software, and exist for computer languages including python <span class="citation">(Harihareswara 2018)</span>, LaTeX <span class="citation">(<span>“CTAN”</span> 2021)</span>, JavaScript <span class="citation">(Goldwater 2020)</span>, and many others <span class="citation">(as well as operating-system specific package distribution services such as described in Debian Policy Editors 2021)</span>. Package distribution services have been analysed and compared both in terms of static collective properties <span class="citation">(for example, Decan, Mens, and Claes 2016)</span>, as well as their temporal evolution, a notable example of which is <span class="citation">Decan, Mens, and Grosjean (2019)</span>, who examined the evolution of dependency networks from seven package distribution systems, including the “Comprehensive R Archive Network”, or CRAN, the focus of the present study. <span class="citation">Decan, Mens, and Grosjean (2019)</span> observed that both numbers of packages and numbers of dependencies have increased more slowly for CRAN than for any of the other systems they considered, as have numbers of package updates. They also observed that the “survival probability” (that a package is updated after some given time) has been far greater for CRAN than for other package ecosystems, albeit with differences observed between packages which are not required or imported by other packages, and those which are. Finally, they observed that the Gini coefficient of inequality between dependent packages has also increased over time in all systems. The total size of the systems studied by both <span class="citation">Decan, Mens, and Claes (2016)</span> and <span class="citation">Decan, Mens, and Grosjean (2019)</span> nevertheless left relatively little scope for detailed examinations of the properties of the packages themselves, leaving analyses more focussed on aggregate properties such as those of dependency networks.</p>
<p>There have also been detailed considerations of dependency networks from individual package distribution systems, such as the analyses of the Debian network by <span class="citation">Gonzalez-Barahona et al. (2009)</span>, who revealed progressive increases in package inter-dependencies. Although they observed increases in the sizes of packages over time, and claimed that these reflected the laws of <span class="citation">Lehman et al. (1997)</span>, they neither quantified nor modelled actual rates of change. They also observed that the relative sizes of packages, measured in terms of lines of code, remained relatively stable across releases. A recent analysis of the “pypi” (Python Package Index) package distribution system for python <span class="citation">(Bommarito and Bommarito 2019)</span> represented the most comprehensive analysis to that time of a single package distribution system for any computer language, drawn from almost two million releases of 179,000 packages. The size of pypi necessarily restricted analyses to package metadata, although single metrics of package size were also included. Moreover, the size of pypi meant that analyses of dependency networks were also restricted to aggregate statistics only, with no analyses of the internal properties of dependency networks themselves. Thus while this represents an exemplary study of the evolution of a package distribution system, the size of this system precluded any analyses of how individual pieces of software evolve both internally, and in relation to the aggregate evolution of the system as a whole.</p>
<p>The primary aim of the present work is to examine the mutual evolutionary dynamics of both the collective properties of one package distribution system and the properties of individual software packages within that system. Detailed examination of the co-evolution of an entire software system along with evolutionary trajectories of individual components requires both a package distribution system of relatively modest size, and one which retains full archives of all previous packages. One package distribution system which fulfils both of these criteria is CRAN, or the Comprehensive R Archive Network, which is around one tenth the size of pypi, although still amounting to over 100,000 releases of around 20,000 packages. CRAN is by far the dominant package distribution system for R; while other systems such as BioConductor and R-Forge have been considered elsewhere <span class="citation">(Decan et al. 2015)</span>, the present work focusses exclusively on CRAN.</p>
<p>This work builds on several prior analysis of CRAN packages. Perhaps most notably, this present article has been prepared ten years after <span class="citation">Hornik (2012)</span> first published his article commemorating his “early history of the R project” ten years prior to that. In his 2012 article, Kurt Hornik, one of the instigators of CRAN, calls for,</p>
<blockquote>
<p>a considerable and concerted community effort … providing R packages to compute on R packages.</p>
</blockquote>
<p>While he was referring in that context specifically to textual analyses of documentation files, his perceived absence of resources to “compute on packages” arguably remains largely true ten years later. Most analyses of the CRAN software system have considered what might be referred to as “metadata”, such as personal networks of package authors <span class="citation">(Plakidas, Schall, and Zdun 2017)</span>, or relationships between CRAN and software development platforms such as GitHub <span class="citation">(Decan et al. 2015, 2016)</span>. Analyses which have considered individual packages have also mostly examined simplified aggregate data such as sizes of packages <span class="citation">(German, Adams, and Hassan 2013)</span>, or dependency networks between packages <span class="citation">(Mora-Cantallops, Sánchez-Alonso, and García-Barriocanal 2020)</span>. The present work aims to extend beyond such analyses, by reporting on a tool able to derive detailed data on the internal structure of every package which has ever existed on CRAN, and to relate such detailed package-internal data to the extrinsic evolution of the system as a whole.</p>
<p>We begin by describing the <a href="https://docs.ropensci.org/pkgstats" class="external-link">the <code>{pkgstats}</code> R package</a>, which can be used to generate and analyse properties of R package code, and the accompanying database of code statistics of all historical CRAN packages. We then describe trends in CRAN package properties over the history of the archive (1998-2021), focussing on trends in four areas: Package metadata (licenses, authorship, translation), internal content and structure (file and function types and sizes), intra-package code structure (function call networks), and finally, dependency networks amongst packages. Finally, we discuss implications and likely drivers of these trends, and potential further applications and extensions of <a href="https://docs.ropensci.org/pkgstats" class="external-link">the <code>{pkgstats}</code> package</a> and database.</p>
</div>
<div class="section level2">
<h2 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a>
</h2>
<p>We developed <a href="https://docs.ropensci.org/pkgstats" class="external-link"><code>{pkgstats}</code></a> to quantify the structure and content of R packages using static code analysis techniques <span class="citation">(Papamichail, Diamantopoulos, and Symeonidis 2016)</span>. That package <a href="https://docs.ropensci.org/pkgstats/reference/pkgstats_from_archive.html" class="external-link">includes a function, <code>pkgstats_from_archive</code></a>, which can be applied to a local mirror of the CRAN archive to collate statistics from all packages. The resultant data have been published with the <a href="https://github.com/ropensci-review-tools/pkgstats/releases/tag/v0.0.3" class="external-link">v0.0.3 release of the {pkgstats} package</a>. All results that follow used the <code>pkgstats-CRAN-all</code> data, which contain one row for each package ever published on CRAN (total of 105,375 rows), and 91 column-wise variables quantifying and qualifying many aspects of each package, as described in the following sub-sections.</p>
<p>This methodological description begins with an overview of the structure of the CRAN archive and how data were extracted, followed by a description of the two open-source libraries for “code tagging” used in the <a href="https://docs.ropensci.org/pkgstats" class="external-link"><code>{pkgstats}</code></a> package. We then describe the results generated by the package itself, before providing details of statistical analyses used to derive these results.</p>
<div class="section level3">
<h3 id="data-r-packages-and-the-cran-server">Data: R packages and the CRAN server<a class="anchor" aria-label="anchor" href="#data-r-packages-and-the-cran-server"></a>
</h3>
<p>Our primary data source comprised every version of every R package hosted on the <a href="https://cran.r-project.org" class="external-link">“Comprehensive R Archive Network” or CRAN</a>, which is the centralised distribution system for R packages. The <code>R</code> language itself is defined by a single “package” referred to as “base R”. By default, all installations of <code>R</code> also <a href="https://github.com/wch/r-source/tree/trunk/src/library" class="external-link">include a suite of “recommended” packages</a>. All packages other than these are referred to as “Contributed Packages”. A number of the following results distinguish between these three categories of base, recommended, and contributed packages <span class="citation">(German, Adams, and Hassan 2013)</span>.</p>
<p>CRAN currently holds close to 19,000 contributed packages, and also maintains a complete archive of all previous versions of all packages, including of archived packages no longer available on CRAN. The data analysed here were generated from a local mirror of the entire CRAN repository, including all current and archived versions of all packages, and amounting to around 105,000 individual versions (for an average of slightly over 5 releases per package). The raw data for these analyses are the contributed packages themselves. While relationships to objects (functions) in the base and contributed packages are considered, the structures of the base and recommended packages are not analysed here.</p>
<p>All R packages must accord with the structure defined in the <a href="https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages" class="external-link">“<em>Writing R Extensions</em>” Manual</a> <span class="citation">(as discussed in Hornik 2012)</span>. Many aspects of the following analyses were applied to different components of R packages, in particular the following main sub-directories:</p>
<ul>
<li>The <code>/R</code> directory which holds all source files in the R language;</li>
<li>The <code>/src</code> directory which holds all code in other languages which needs to be compiled on package installation;</li>
<li>The <code>/inst</code> directory which generally holds bundles of external code, but may also include code used for cross-linking in compilation, including of other packages. Cross-linked code must be in an <code>/inst/include</code> sub-directory (as explained in <a href="https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages" class="external-link">this section of the “<em>Writing R Extensions</em>” Manual</a>). All of the following analyses only consider the <code>/inst/include</code> directory, and all references to the <code>/inst</code> directory imply this sub-directory only. Analyses excluded all other sub-directories within the <code>/inst</code> directory.</li>
<li>The <code>/vignettes</code> directory which includes extended documentation. (Such documentation may also be placed in an <code>/inst/doc</code> folder, but this was ignored here.)</li>
<li>The <code>/tests</code> directory containing test files.</li>
<li>The <code>/data</code> directory containing data files used to implement or demonstrate package functionality.</li>
</ul>
<p>The results which follow also distinguish between the two main kinds of R functions:</p>
<ul>
<li>Exported functions intended to be called by users of a package; and</li>
<li>Non-exported functions intended only to be called internally by other functions of a package.</li>
</ul>
</div>
<div class="section level3">
<h3 id="code-tagging-with-ctags-and-gtags">Code tagging with “ctags” and “gtags”<a class="anchor" aria-label="anchor" href="#code-tagging-with-ctags-and-gtags"></a>
</h3>
<p>The <a href="https://docs.ropensci.org/pkgstats" class="external-link"><code>{pkgstats}</code></a> package is a static code analysis tool specifically developed for R packages, with much of the functionality extending from two general static analysis tools. Static code analysis tools generally work by constructing parse trees which relate a grammar describing one or more computer languages to each expression encountered by tracing the code. An important first step is to “tag” each expression, identifying the kind of expression and its scope, generally implying its membership either of some component of the underlying grammar, or some more local scope such as definitions within locally-sourced files.</p>
<p><a href="https://docs.ropensci.org/pkgstats" class="external-link"><code>{pkgstats}</code></a> uses two open-source libraries for code tagging and parse tree construction: “ctags” and “gtags”. The original “ctags” library is no longer maintained, and these analyses used a maintained version called <a href="https://ctags.io" class="external-link">“Universal ctags”</a> which,</p>
<blockquote>
<p>generates an index (or tag) file of language objects found in source files for programming languages.</p>
</blockquote>
<p>This library was used here to tag each expression in the <code>R</code>, <code>src</code>, and <code>inst/include</code> directories, providing the following data for each tagged item:</p>
<ol style="list-style-type: decimal">
<li>The tag itself, such as the name of a function, variable, or other object;</li>
<li>The name and path of the corresponding file;</li>
<li>The full content of the expression in which that tag was used (as a text string);</li>
<li>The kind of object (in <code>R</code> files, generally a <code>function</code>, <code>functionVar</code> or variable defined within a function, <code>globalVar</code> for global variables, or other objects defined by the <code>R</code> language; kinds of objects can be arbitrarily diverse in other languages);</li>
<li>The computer language in which that object was referenced; and</li>
<li>The start and end line numbers of the file in which that object is defined or referenced.</li>
</ol>
<p>The “ctags” data for R files were also used to construct an “external call network” of references to all R functions in all packages, including the package being analysed, the base and recommended packages, and all other contributed packages imported by each package. Functions were attributed to packages by matching function names. Function names in R do not have to be unique, and <a href="https://conflicted.r-lib.org/" class="external-link">“namespace conflicts”</a> may arise between packages implementing different functions with the same name. We presumed that namespace conflicts most commonly arise in re-definitions of functions initially defined in base or recommended packages, and in all such cases we attributed a function to the external or contributed package over definitions in the base or recommended packages.</p>
<p>The “gtags” library, itself part of the <a href="https://www.gnu.org/software/global/" class="external-link">GNU Global library</a>, generates entries for every expression, with the “tag” itself defining the environment for that expression. This enables mappings to be made between every expression and its corresponding tag. We used “gtags” to construct object reference networks across all computer languages used in R packages (such as C, C++, or Python), to enable the construction of “function call networks” within and between all languages. While the terms “functions” and “calls” may not be appropriate for all computer languages and/or classes or types of objects, they nevertheless reflect the functionality of R code, and so are preferred here, even when referring to other object relationships such as class inheritance mechanisms.</p>
<p>It is possible to cross-compile “gtags” with “ctags”, to enable “gtags” to use the more expansive language parsing abilities of “ctags”, and to greatly extend the range of languages able to be parsed by “gtags”. In particular, “gtags” does not not by default parse R code, yet does so when cross-compiled with Universal “ctags”. Cross-compiled installations of “gtags” are, however, generally several times slower than simpler installations, and so these analyses did not use a cross-compiled version. While this meant restricting analyses to a smaller subset of potential languages, the output of “ctags” itself nevertheless describes tags in all possible languages, with “gtags” only used to map function call networks in languages other than R. Function-call networks within R were extracted from the “ctags” output as described above, and one additional function was written in the <code>{pkgstats}</code> package to link calls within R code as defined by the “ctags” output to external objects defined in other languages and specified by the “gtags” output. This enabled full function-call networks to be constructed within and between different languages used in R packages.</p>
<p>Data generated by “ctags” and “gtags” which were analysed here included:</p>
<ul>
<li>Numbers of internal and external functions in R.</li>
<li>Numbers and kinds of all objects in all other languages.</li>
<li>Numbers of Lines-of-Code for each function or object definition in each language.</li>
<li>References from each function (or object) made to all other functions (or objects), including references made to all functions defined in other base, recommended, or contributed R packages.</li>
</ul>
</div>
<div class="section level3">
<h3 id="the-pkgstats-package">The <code>pkgstats</code> package<a class="anchor" aria-label="anchor" href="#the-pkgstats-package"></a>
</h3>
<p>This sub-section describes additional data generated by <a href="https://docs.ropensci.org/pkgstats" class="external-link"><code>{pkgstats}</code></a> beyond that extracted from “ctags” and “gtags”. The full list of all data generated by the package is given in <a href="https://docs.ropensci.org/pkgstats/" class="external-link">the online documentation</a>, with this sub-section only describing those aspects which were analysed here.</p>
<div class="section level4">
<h4 id="description-files">‘DESCRIPTION’ files<a class="anchor" aria-label="anchor" href="#description-files"></a>
</h4>
<p>All R packages must include a <a href="https://www.debian.org/doc/debian-policy/ch-controlfields.html" class="external-link">Debian Control File</a> (“DCF”) called “DESCRIPTION” <span class="citation">(Hornik 2012)</span> which contains a subset of standard DCF fields, including <a href="https://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file" class="external-link">a number of standardised and mandatory fields</a> able to be analysed here. We extracted:</p>
<ul>
<li>Numbers of authors (as individuals with a specified role of “aut”);</li>
<li>Numbers of contributors (as individuals with a specified role of “ctb”);</li>
<li>Full entries of the “License” field specifying the type of license under which the software was released; and</li>
<li>Entries in the “URL” field specifying one or more Uniform Resource Locators (URLs) for the package.</li>
<li>Lists of all imported packages used to construct dependency networks between packages. (Neither required nor suggested packages were considered here.)</li>
</ul>
</div>
<div class="section level4">
<h4 id="translation-files">Translation files<a class="anchor" aria-label="anchor" href="#translation-files"></a>
</h4>
<p>R packages may include <a href="https://cran.r-project.org/doc/manuals/R-exts.html#Preparing-translations" class="external-link">files used to translate all messages issued by code into other (human) languages</a>. These files are placed in a dedicated <code>/po</code> sub-directory, with file names prefixed with standard prefixes (generally, but not necessarily, <a href="https://en.wikipedia.org/wiki/ISO_639-1" class="external-link">ISO 639-1 codes</a>). This format enables translations to be readily identified and extracted. <code>{pkgstats}</code> extracts a list of all translations provided for each package.</p>
</div>
<div class="section level4">
<h4 id="lines-of-code-loc">Lines of Code (LoC)<a class="anchor" aria-label="anchor" href="#lines-of-code-loc"></a>
</h4>
<p><a href="https://docs.ropensci.org/pkgstats" class="external-link"><code>{pkgstats}</code></a> includes its own internal tool (coded in C++) for counting Lines-of-Code (Loc). This tool produces output similar to many common LoC tools, with additional data on:</p>
<ol style="list-style-type: decimal">
<li>Total numbers of code, comment, and blank lines;</li>
<li>Total numbers of characters in code lines, along with total numbers of white-space characters, to enable metrics of proportional white space; and</li>
<li>Code indentation, including identification of tab-indentation.</li>
</ol>
<p>These white-space and indentation metrics were developed to enable quantification of aspects of code outlay and design.</p>
</div>
<div class="section level4">
<h4 id="function-level-analyses">Function-level analyses<a class="anchor" aria-label="anchor" href="#function-level-analyses"></a>
</h4>
<p>The “ctags” and “gtags” output described above provides data on the start and end points of each function definition, along with names of associated files. These data were used to provide estimates of average LoC per function, and numbers of function definitions per file. (Where, as explained above, “function” is used here as generic label for any object in any language, such as class definitions.)</p>
<p>Each exported function in an R package must have a corresponding documentation file in the <code>/man</code> directory of the package with the suffix, <code>.Rd</code> for “R documentation”. <a href="https://docs.ropensci.org/pkgstats" class="external-link"><code>{pkgstats}</code></a> also statically parses these files with <a href="https://stat.ethz.ch/R-manual/R-devel/library/tools/html/parse_Rd.html" class="external-link">the <code>parse_Rd</code> function of the recommended <code>{tools}</code> package</a>. For the present analyses, this enabled identification of the number of parameters for each function, and the number of documentation characters for each parameter. Total length of documentation for each function was also quantified as the number of lines in the output produced by converting the result of <code>parse_Rd</code> to text (via the <code><a href="https://rdrr.io/r/tools/Rd2HTML.html" class="external-link">tools::Rd2txt</a></code> function).</p>
</div>
</div>
<div class="section level3">
<h3 id="network-analyses">Network Analyses<a class="anchor" aria-label="anchor" href="#network-analyses"></a>
</h3>
<p>Two distinct kinds of network analyses were performed here: <em>inter-package</em> analyses of dependency networks between packages <span class="citation">(akin to Decan, Mens, and Grosjean 2019)</span>, and <em>intra-package</em> analyses of the function call networks extracted from the “ctags” and “gtags” data described above.</p>
<div class="section level4">
<h4 id="inter-package-network-analyses">Inter-Package Network Analyses<a class="anchor" aria-label="anchor" href="#inter-package-network-analyses"></a>
</h4>
<p>The ‘DESCRIPTION’ files of R packages must specify all external packages which a package imports. These data can be used to construct a full dependency network between all packages. The results below present the following measures derived from package dependency networks, all of which were calculated with the <a href="https://igraph.org" class="external-link">igraph</a> package <span class="citation">(Csardi and Nepusz 2006)</span>.</p>
<ol style="list-style-type: decimal">
<li>Numbers of packages which are not imported by any others - the terminal vertices in a dependency network;</li>
<li>Average “in-degree” of network vertices, or average numbers of times each package is imported by others;</li>
<li>The average <em>betweenness centrality</em> of each edge, which is the number of times that edge is traversed in connecting every package to every other package in the network;</li>
<li>The network-level <em>degree centrality</em>, which is a measure of vertex degree standardised to the overall size and structure of the network <span class="citation">(Freeman 1978)</span>.</li>
<li>A measure of the overall “size” of the network as the average distance between all pairs of vertices.</li>
</ol>
<p>Betweenness centrality provides insight into how centralised the network is, with higher values reflecting networks in which connections frequently traverse a common, central region. The network-level degree centrality reflects the extent to which vertices all have a relatively high in-degree; networks in which all networks have an equal in-degree have no effective centre, and so have a degree centrality of zero. In contrast, networks with a few highly-connected central vertices and many vertices with low in-degree will have a high degree centrality. These two centrality metrics provide slightly different insights: betweenness centrality will increase to the extent to which a network manifests a single, common centre; degree centrality will increase to the extent that networks become more centralised in general, regardless of whether or not any singly identifiable centre forms.</p>
<p>Networks with low degree centrality are readily traversable, and so will generally have lower average distances between all pairs of vertices. The distance metric nevertheless may offer additional insight, and will for example be higher independent of degree centrality for networks with extended peripheral connections. Finally, we note that clusters or local network communities were not considered here, as the dependency networks of CRAN packages are almost always so highly connected that the largest connected cluster represents over 99% of the network.</p>
</div>
<div class="section level4">
<h4 id="intra-package-network-analyses">Intra-Package Network Analyses<a class="anchor" aria-label="anchor" href="#intra-package-network-analyses"></a>
</h4>
<p>Intra-package networks were constructed from the function call networks described above, and included overall package networks connecting code in all sub-directories, as well as network analyses of only those components representing individual sub-directories, here constrained to network analyses of both <code>/R</code> and <code>/src</code> code. Function call networks within individual packages are commonly structured in several distinct clusters, and thus numbers of clusters provided an important first metric for intra-package analyses. Intra-package analyses considered the following metrics:</p>
<ol style="list-style-type: decimal">
<li>Ratio of numbers of edges to numbers of vertices.</li>
<li>Numbers of distinct clusters between all functions or objects across all languages.</li>
<li>The betweenness centrality of the function call network.</li>
<li>Numbers of terminal vertices (functions which do not call any other functions).</li>
<li>The average vertex degree.</li>
</ol>
</div>
</div>
<div class="section level3">
<h3 id="coupling-instability">Coupling Instability<a class="anchor" aria-label="anchor" href="#coupling-instability"></a>
</h3>
<p><a href="https://en.wikipedia.org/wiki/Software_package_metrics" class="external-link">Coupling Instability</a> is an important concept in the analysis of software dependency networks <span class="citation">(Martin 2003)</span>, and depends in turn on numbers of so-called <em>afferent</em> and <em>efferent</em> couplings. For any given package, these are defined as:</p>
<ul>
<li>
<em>Afferent Couplings</em> as numbers of functions in other packages which depend on functions within the package.</li>
<li>
<em>Efferent Couplings</em> as numbers of functions from other packages which the package depends on.</li>
</ul>
<p>In other words,</p>
<ul>
<li>
<em>Afferent</em> couplings are numbers of <em>inbound</em> edges from all other packages to a given package, while</li>
<li>
<em>efferent</em> couplings are <em>outbound</em> edges coupling that package with all other packages.</li>
</ul>
<p>Respectively denoting afferent and efferent couplings by <span class="math inline">\(n_a\)</span> and <span class="math inline">\(n_e\)</span>, the coupling instability, <span class="math inline">\(I\)</span>, is defined as <span class="math inline">\(I = n_e / (n_e + n_a)\)</span>. Packages which depend on many external calls (high efferent couplings), yet upon which few other packages depend (low afferent couplings) thus have a high coupling instability, while packages upon which many other packages depend, yet which themselves depend on few other packages have a low coupling instability. The analyses below quantified coupling instability for each package from the dependency networks, using total numbers of function calls between all packages, in order to estimate the average coupling instability of the entire network.</p>
<p>We also adapted this measure of coupling instability <em>between packages</em> to a measure of <em>internal</em> coupling instability <span class="citation">(Almugrin and Melton 2015)</span> between the individual files of one package. Packages with high internal coupling instability make many calls between individual files, while packages with low instability make more calls within single files, and relatively fewer between them.</p>
</div>
<div class="section level3">
<h3 id="statistical-analyses">Statistical Analyses<a class="anchor" aria-label="anchor" href="#statistical-analyses"></a>
</h3>
<p>The following results depict and interpret qualitative trends and patterns, without implementing or reporting values for any statistical tests. Data were sufficiently large (N &gt; 105,000) to ensure that all of the reported results were entirely significant in frequentist terms. There are two further important aspects to note in regard to statistical analyses detailed below.</p>
<div class="section level4">
<h4 id="temporal-analyses">Temporal Analyses<a class="anchor" aria-label="anchor" href="#temporal-analyses"></a>
</h4>
<p>Most of the following results depict the evolution of CRAN software over time, in two main ways:</p>
<ol style="list-style-type: decimal">
<li>As annual developments averaged over all packages; or</li>
<li>As developments for individual packages over sequences of releases.</li>
</ol>
<p>Several of the following results are accordingly divided into the corresponding sub-sections of “Annual Developments” and “Sequential Releases,” respectively referring to these two modes of analysis. Annual developments aggregate values over all packages for each year, while sequential developments aggregate values over each sequential release, so that the first versions of all packages are aggregated for a release sequence of one, second versions for release sequence two, and so on. Annual developments thus capture the collective development of the system as a whole, while sequential developments capture the development of individual packages.</p>
<p>For continuously updated repositories like CRAN, annual developments can be captured in the following two primary ways:</p>
<ol style="list-style-type: decimal">
<li>Through considering each year to represent the state of CRAN at that time, and thus to include latests releases of all packages for that year, regardless of how long ago a package may previously have been updated. Annual estimates derived this way are referred to here as <strong>CRAN snapshots</strong>.</li>
<li>Through considering each year to represent only the state of CRAN in terms of packages uploaded in that specific year, disregarding any packages uploaded in prior years. Estimates derived this way are referred to simply as <strong>annual</strong> values.</li>
</ol>
<p>Under the plausible assumption that rates of package updates follow some kind of Poisson-like process, the ages of packages at any given time will be exponentially distributed, analogous to distributions of waiting times for Poisson processes. This means that values derived using <strong>CRAN snapshots</strong> will generally reflect exponentially-smoothed versions of <strong>annual</strong> values. Many of the graphical results which follow depict results dervied using both of these approaches, in which:</p>
<ul>
<li>solid lines represent annual values, which are generally noiser versions of</li>
<li>dashed lines, which represent effectively exponentially-smoothed versions of the same data using CRAN snapshots for each year.</li>
</ul>
<p>Where no additional interpretations are given, solid lines in all of the results that follow represent annual values, while dashed lines represent results derived from CRAN shapshots. See Fig. 1A immediately below, for an example. Where also not otherwise mentioned, all reported values refer to (generally noisier) annual values, and not to values derived from (generally smoother) CRAN snapshots.</p>
</div>
</div>
<div class="section level3">
<h3 id="distributional-properties-and-mean-values">Distributional properties and mean values<a class="anchor" aria-label="anchor" href="#distributional-properties-and-mean-values"></a>
</h3>
<p>Almost all statistics described above, and presented in the results below, were approximately log-normally distributed. References in any of the following results to mean values thus imply values calculated as <code>10^mean(log10(x))</code>. The use of direct mean values did not generally alter any of the qualitative conclusions which follow, yet resulted in many cases in less distinct or smooth trajectories or results.</p>
</div>
</div>
<div class="section level2">
<h2 id="results">Results<a class="anchor" aria-label="anchor" href="#results"></a>
</h2>
<p>Many of the following results reveal pronounced changes broadly centered around 2010. It is important in interpreting such results to note that the largest public code hosting platform, GitHub, launched in 2008. This changes from that year onward are very likely influenced by the increased public accessibility of code, as discussed further below.</p>
<div class="section level3">
<h3 id="metadata">Metadata<a class="anchor" aria-label="anchor" href="#metadata"></a>
</h3>
<p>Numbers of both authors and contributors have increased over time (Fig. 1A), with contributors having been rarely acknowledged at all prior to 2010, increasing to an average of just under one acknowledged contributor per package in 2021. Numbers of unique licenses primarily reflect numbers of ways of declaring licenses, rather than numbers of actual licenses (for example, “GPL &gt;= 2.0” is different to “Any GPL license version 2 or higher”, although both clearly refer to the same license). Figure 1B shows a roughly linear increase in license declarations up to around 2007, followed by a pronounced drop and progression into a roughly stable range of somewhere over 50 distinct entries. The different ways of specifying the three versions of GPL licenses have accounted for over 83% of all CRAN packages, with the second most common type license being MIT, at 9.6%, followed by BSD at 2.0%. One of these three classes of licenses are used in 95% of all CRAN packages.</p>
<div class="figure">
<img src="figures/fig01.png" alt=""><p class="caption"><strong>Figure 1.</strong> Annual developments of metadata from package ‘DESCRIPTION’ files.</p>
</div>
<p>The practice of translating messages within R packages into other languages has steadily declined in recent years (Fig. 2A), suggesting a pronounced increase in acceptance over the last 15 or so years of English as a globally standard language, and a concomitant decrease in active acknowledgement of other languages. (The <code>en@quot</code> translation entry in Fig. 2A is described in the <a href="https://cran.r-project.org/doc/manuals/R-admin.html#Localization-of-messages" class="external-link"><em>R Installation and Administration</em> Manual</a> as a translation which, “can be used in a UTF-8 locale to have American error messages with pairs of single quotes translated to Unicode directional quotes.”) Rates of decrease since 2008 equate to 1.5% fewer packages per year including translations, from a total of just over 20% of all packages in 2008, to barely over 1% in 2021. While rates of decrease have slowed somewhat in recent years, extrapolation of the preceding five years nevertheless suggests that the practice of offering translations will effectively disappear before the end of the coming year (2023).</p>
<div class="figure">
<img src="figures/fig02.png" alt=""><p class="caption"><strong>Figure 2.</strong> (A) Annual frequencies of the top 10 translations. (B) Annual frequencies of the top 10 primary URL domains, with frequencies for GitHub divided by 20.</p>
</div>
<p>Analyses of URLs provided in package ‘DESCRIPTION’ files clearly reveal an abrupt break after around 2010 with the advent of online code repositories (Fig. 2B). GitHub has always dominated, while r-forge has declined progressively since around 2015. The most notable increase has been the emergence of rOpenSci as provider of the only URL to come close to within 1/20th of the popularity of GitHub over the past few years.</p>
</div>
<div class="section level3">
<h3 id="package-structure-and-content">Package Structure and Content<a class="anchor" aria-label="anchor" href="#package-structure-and-content"></a>
</h3>
<p>The temporal development of numbers of files manifest several notable characteristics (Figure 3). Unsurprisingly, R packages have always been dominated by files in the <code>R/</code> directory, numbers of which increased considerably up to around 2010, after which they have generally stabilised at mean values of around 13-15 files per package (Fig. 3A). The <code>/vignettes</code> directory is the only place within R packages in which numbers of files have remained relatively constant over the preceding 20+ years. Packages generally had very few files in the <code>inst</code> directory prior to 2010, after which they increased until around 2015, before decreasing again more recently. The two sub-directories in which numbers of files have increased most significantly are <code>/src</code> and <code>/tests</code>, with the latter increase particularly distinct, clearly indicating that packages have become progressively better tested.</p>
<div class="figure">
<img src="figures/fig03.png" alt=""><p class="caption"><strong>Figure 3</strong> (A) Number of files in different diretories per year (with legend in panel B). Solid lines represent loess-smoothed interpolations, while dashed lines are raw annual values (not CRAN snapshots). (B) Numbers of files as a function of release sequence.</p>
</div>
<p>Figure 3B shows equivalent changes within individual packages across successive releases. Numbers of files generally progressively increase as packages mature, with especially pronounced increases in the <code>/R</code> and <code>/inst</code> directories, the latter somewhat offset after around 15 releases by decreases in the <code>src</code> directory. These changes in <code>/src</code> and <code>/inst</code> directories in the later phases of package maturation may reflect restructuring code from the <code>/src</code> to the <code>/inst</code> directories in order to allow cross-compilation by other packages. Numbers of test files generally increase out to around 15 releases, after which they generally stabilise. The only directory in which numbers of files do not notably increase as packages mature is <code>/vignettes</code>.</p>
</div>
<div class="section level3">
<h3 id="code-metrics">Code Metrics<a class="anchor" aria-label="anchor" href="#code-metrics"></a>
</h3>
<div class="section level4">
<h4 id="annual-developments">Annual Developments<a class="anchor" aria-label="anchor" href="#annual-developments"></a>
</h4>
<p>Figure 4 shows the temporal evolution of a number of code metrics. Lines of Code (“LoC”) in the primary <code>/R</code> and <code>/src</code> sub-directories broadly increased up to around 2005-2010, after which time LoC in these directories have slightly decreased, converging on just over 600 lines in both <code>/R</code> and <code>/src</code> directories. These trends are broadly reflected in LoC per function (Fig. 4B), excepting the early years of CRAN, during which functions often had well over 100 lines each, especially <code>/src</code> functions defined in other languages (in those years, primarily Fortran and C). That panel, as well as Fig. 4C, distinguishes between the two primary kinds of R functions, exported and non-exported. LoC per function have remained broadly stable for almost 20 years, at around 30 lines for all function types and languages. The slight decrease discernible since around 2015 amounts to one LoC less for exported, non-exported, and <code>/src</code> functions every 3.4, 8.5, and 1.5 years, respectively.</p>
<p>Total numbers of R functions initially increased until around 2007, peaking at just under 30 exported and over 50 non-exported functions per package (Fig. 4C). Numbers of exported R functions have decreased since then to around 17 exported and 40-45 non-exported functions per package in 2021. Numbers of functions defined in <code>/src</code> directories have followed broadly similar trajectories to exported <code>/R</code> functions, slightly decreasing since the early 2000’s to between 30-40 functions. Numbers of functions per source file in both <code>/R</code> and <code>/src</code> directories have nevertheless progressively decreased since the early 2000’s to now amount to less than four <code>/R</code> functions and just over five <code>/src</code> functions per file (Fig. 4D).</p>
<div class="figure">
<img src="figures/fig04.png" alt=""><p class="caption"><strong>Fig. 4</strong> Annual development of code metrics.</p>
</div>
</div>
<div class="section level4">
<h4 id="sequential-releases">Sequential Releases<a class="anchor" aria-label="anchor" href="#sequential-releases"></a>
</h4>
<p>Figure 5 shows results equivalent to Fig. 4, but for the development of the respective metrics with each sequential release of a package, rather than annual developments. Lines of code generally increase as packages mature, with mean numbers of lines in the <code>/R</code> directory increasing tenfold from under 400 for first releases to over 5,000 in packages with 100 or more releases. LoC in <code>/inst</code> directories also tend to increase as packages develop, although to a lesser extent, and only becoming notable after around 50 releases. Beyond the first few releases, there are always fewer LoC in <code>/src</code> directories than in <code>/R</code> directories. This contrasts with the annual aggregate results of Fig. 4A, which suggest more LoC in <code>/src</code> than <code>/R</code> directories until around 2007, and roughly equal numbers since then. This difference reflects the fact that most packages have only one or two releases (the distribution of numbers of releases is not shown here, but manifests a very smooth exponential decrease), so Fig. 4A is dominated by packages in a very early state of development, for which LoC in <code>/src</code> often exceed numbers in <code>/R</code>. Similar to patterns for <code>/src</code> and <code>inst</code> directories in Fig. 3B, decreases in LoC in <code>/src</code> directories in the later phases of package maturation may reflect restructuring code to <code>/inst</code> directories. This clear peak in LoC in <code>/src</code> directories may in turn suggest this is an approximate number of releases before other developers become aware of the functionality of package <code>/src</code> directories. The clearest result of Fig. 4A is manifest in total LoC, which increases in a strikingly linear manner even out to the 100th release of a package.</p>
<div class="figure">
<img src="figures/fig05.png" alt=""><p class="caption"><strong>Fig. 5</strong> Development of code metrics per release of each package.</p>
</div>
<p>These increases in LoC nevertheless corresponded to general decreases in LoC per function with increasing numbers of releases (Fig. 5B). In all directories, LoC per function either slightly increased or remained generally stable over the first 50 or so releases, beyond which functions in all directories clearly become considerably more streamlined, with LoC decreasing markedly out to the 100th release. Similar to the aggregate LoC measures of panel A, LoC in <code>/src</code> directories manifest a distinct peak as packages matured, with LoC per <code>/src</code> function peaking slightly earlier (after around 40 releases) than total LoC (slightly over 50). The decreases in the latter portions of Fig. 5B are nevertheless relatively minor, and amount to removing one LoC per function for every 5, 7, or 18 releases for exported R, non-exported R, and source function, respectively.</p>
<p>The increasing total measures of LoC of panel A combined with decreasing LoC per function of panel B must mean that more functions are added as packages mature, which is precisely what Fig. 5C reveals. Packages initially contain less than ten exported functions on average, yet this increases over 10-fold to over 130 by the 100th release. Numbers of <code>/src</code> functions are initially higher, at around 20, and increase relatively less than equivalent <code>/R</code> functions, to around 100 after 100 releases. Numbers of non-exported <code>/R</code> functions manifest the most pronounced increase, of over 15 times from 20 functions for initial releases, to well over 300 for the 100th release. Finally, numbers of functions per file show no clear trend for <code>src</code> code, remaining broadly stable at around six functions per file (Fig. 4D). In contrast, <code>/R</code> code files begin with 3-4 functions per file, and increase progressively to around eight functions per file after 100 releases, in the context of Figs. 4B-C clearly mostly due to breaking large non-exported functions down into multiple, smaller functions.</p>
<p>Numbers of functions depicted in Fig. 4C actually count any arbitrary code objects in all languages contained in <code>/src</code> directories, and so corresponds directly to the “modules” posited to increase according to the inverse-square “law” of software evolution <span class="citation">(Turski 1996, 2002; Lehman et al. 1997)</span>. The defining qualitative feature of such inverse–square growth is an initially highly concave form, with rates decreasing notably as packages mature. The trajectories of Fig. 4C appear in contrast strikingly linear, all manifesting trajectories which would be very poorly described by such an inverse-square form.</p>
</div>
</div>
<div class="section level3">
<h3 id="package-imports-and-exports">Package Imports and Exports<a class="anchor" aria-label="anchor" href="#package-imports-and-exports"></a>
</h3>
<p>Like the “standard” libraries for the python language, R has a core set of “base” and “recommended” packages. The function call networks extracted by <code>pkgstats</code> enable counting numbers of calls to each of these groups of packages, as well as to “contributed” packages hosted on CRAN.</p>
<div class="section level4">
<h4 id="annual-developments-1">Annual Developments<a class="anchor" aria-label="anchor" href="#annual-developments-1"></a>
</h4>
<p>Figure 6A shows the change over time in proportions of calls to these three groups of packages, revealing a recent tendency (since around 2015) of fewer calls to base R functions, from over 80% of all function calls in the early 2000s, to below 70% in the previous two years. This decrease has been offset by greater numbers of calls to functions in contributed packages, while calls to recommended packages have remained generally stable at around 20%. Although calls to contributed packages have always represented the lowest proportion of these three groups, this recent increase nevertheless places them on almost equal proportion (at 12%) to calls to recommended packages (at 18%).</p>
<div class="figure">
<img src="figures/fig06.png" alt=""><p class="caption"><strong>Fig. 6</strong> Dependency networks between packages over time. (A) Proportions of function calls to the three categories of packages. (B) Coupling instability from package funciton calls. (C) Gini coefficients from both package dependency networks, and numbers of funciton calls. (D) Aggregate numbers of calls makde to the top ten imported packages.</p>
</div>
<p>Figure 6B shows the “coupling instability” of packages over time. As explained above, this is a measure of the extent to which packages depend on external functionality (efferent couplings) without other packages in turn depending on them (afferent couplings). Packages on CRAN were largely stable until around 2010, at a coupling instability of around 0.5, meaning numbers of functions from each package which were imported by other packages were roughly equal to numbers of external functions each package imported. Instability has increased markedly since that time, indicating that packages have become increasingly dependent on external functionality, while the average package is less likely to provide functionality used by other packages. The coupling instability over the preceding two years of around 80% implies that packages make on average eight calls to other packages for every two calls made to that package.</p>
<p>As another aggregate measure of changes in package imports, <span class="citation">Decan, Mens, and Grosjean (2019)</span> analysed Gini coefficients, which are standardised aggregate differences in numbers of imports between packages. Systems in which all packages import equal numbers of dependencies have a Gini coefficient of zero, while systems with maximally heterogeneous numbers of imports have a Gini coefficient of one. While they concluded that Gini coefficients have increased over time for all seven of the package distribution systems they studied (including CRAN), at least over their time period of 2012-2017, our equivalent results are depicted in Fig. 6C, revealing a profound dependence on how annual values are defined and calculated. Using “annual values” through aggregating statistics only from packages uploaded in each year (solid lines) yields Gini coefficients which decrease over time, while calculating annual values as “CRAN snapshots” as the entire system would have existed for each year (dashed lines) yields Gini coefficients which increase over time. Their results appear to qualitative accord with our “CRAN snapshot” values for package dependency networks, although our values are only around half of theirs, suggesting that they perhaps neglected a final divisor of 2 in their calculations.</p>
<p>Moreover, that panel depicts Gini coefficients calculated both from numbers of imported packages, and total numbers of external function calls. Numbers of function calls will only equal numbers of imported packages when only one function is used from each package, otherwise numbers of function calls must be greater, leading to larger Gini coefficients of inequality in numbers of external function calls between packages. Other than this expected difference in scale, results from both single-package imports and numbers of functions were qualitatively similar.</p>
<p>Finally, figure 6D depicts changes in numbers of unique function calls from each package to the top ten contributed packages, defined as the ten packages with the largest total number of unique function calls from all packages throughout the history of CRAN. The top two packages of {ggplot2} and {dplyr} account for 16.6% of all function calls from all contributed packages over the time shown. Numbers of function calls are shown on a logarithmic scale, with numbers of calls to each of these packages increasing exponentially between 2013 and 2018, before levelling off or even slightly decreasing.</p>
</div>
<div class="section level4">
<h4 id="sequential-releases-1">Sequential Releases<a class="anchor" aria-label="anchor" href="#sequential-releases-1"></a>
</h4>
<p>The first two panels of Figure 7 show results equivalent to Figs 6A-B, but for changes with progressive releases of each package. Packages tend to make progressively fewer calls to base R functions as they mature, although this decrease is relatively less pronounced than the overall decrease over time of Fig. 6A. However, in stark contrast to Fig 6A, in which decreases over time were offset by relative increases in calls to contributed packages, decreases in calls to base R functions as packages mature are offset by relative increases to calls to recommended packages, while calls to contributed packages actually decrease. Such changes become relatively less pronounced as packages mature, stabilising after around 50 releases at around 75% of all function calls to base R, and just under 25% to contributed packages.</p>
<div class="figure">
<img src="figures/fig07.png" alt=""><p class="caption"><strong>Fig. 7</strong> Dependency networks between packages over sequential releases. (A) Proportional of calls to base and recommended packages across successive releases. (B) Coupling instability. (C) Average numbers of functions from each package imported by other packages, and averge numbers of times packages are imported by other packages.</p>
</div>
<p>Figure 7B shows the average trajectory of coupling instability for individual packages across the depicted numbers of sequential releases, which decreases very progressively as packages mature, as should be expected if packages are increasingly likely to be imported by other packages (that is, as incoming or afferent couplings increase). That figure also shows average numbers of efferent couplings, or numbers of outward calls from each package to other packages, which stay largely stable as packages develop. Increases in package stability thus arise as packages develop purely through being imported as dependencies by increasing numbers of other packages. This in turn suggests that the best way to counteract the increasing coupling instability of CRAN as a whole depicted in Fig. 6B would be to ensure that packages remain progressively developed, rather than abandoned (or archived) after only a few releases.</p>
<p>Finally, Fig. 7C shows progressions of both packages and individual functions being imported into other packages as a function of release sequence. The number of packages importing a package increases progressively with numbers of releases, as was already clear from Fig. 7B. Packages with less than ten releases are, on average, imported by very few other packages, while packages with 40 or more releases are imported by ten other packages on average. The second line on that figure nevertheless reveals that packages import on average only 1-2 functions from any given package, and that numbers of functions imported by other packages increase only marginally as packages mature.</p>
<p>Coupled with the observed increases in numbers of exported functions as packages mature depicted in Fig. 5C, the slight increase in numbers of functions imported by other packages nevertheless suggests a relationship between total numbers of functions exported by a package, and numbers imported by other packages. Indeed, taking only the latest versions of all packages and relating these two values reveals that other packages are likely to import one additional function on average for every 2.8 additional functions exported by a package.</p>
</div>
</div>
<div class="section level3">
<h3 id="network-analyses-1">Network Analyses<a class="anchor" aria-label="anchor" href="#network-analyses-1"></a>
</h3>
<div class="section level4">
<h4 id="annual-developments-2">Annual Developments<a class="anchor" aria-label="anchor" href="#annual-developments-2"></a>
</h4>
<p>The first two panels of Fig. 8 show the temporal development of the CRAN package dependency network, in both cases revealing that most network metrics have broadly stabilised over the preceding five or so years, and that variations were much more pronounced prior to around 2015. The proportion of terminal vertices, or packages not imported by any other packages, has remained broadly stable at around 55-60% of all packages. The mean vertex degree of the dependency network has nevertheless progressively increased, especially since 2015, indicating that those packages which are imported by others have been imported by increasing numbers of other packages (Fig. 8A).</p>
<!--

# dependency networks over time

-->
<div class="figure">
<img src="figures/fig08.png" alt=""><p class="caption"><strong>Figure 8</strong> Network metrics for (A-B) the CRAN dependency network, and (C-D) Function call networks within packages.</p>
</div>
<p>Such an increase in average numbers of imports must increase the overall connectivity of the dependency network, with Fig. 8B showing concomitant decreases in both centrality metrics over time. Average distances between each pair of packages in the network increased notably up to around 2013, after which time they have progressively decreased. Since numbers of terminal vertices have remained generally stable, while centrality has decreased, the initial increase in mean distance likely reflects terminal vertices becoming nevertheless further away, for example through the network evolving a number of distinct centres. The more recent decrease in mean distance may then reflect an equivalent centralisation of the dependency network.</p>
<p>The lower two panels of Fig. 8 depict the evolution of function call networks within individual packages. Fig. 8C shows the ratio of numbers of edges to numbers of vertices, with higher values indicating more densely connected networks. Since around 2005, network connections within R functions, whether exported or not, have remained largely constant, with each function being called by around 5-6 other functions. Connections between functions in <code>/src</code> directories have in contrast decreased considerably, with each <code>/src</code> function (or object) now being “called” (or referenced, inherited, or any other method) by just over one other function. Ratios of edges to vertices in the full function call network extending between all directories (including <code>/inst</code>) has progressively declined from over 4 calls per function to less than 3 in recent years. Function call networks form on average around three distinct clusters for each package, peaking at over 3.5 in 2007 before more recently decreasing to just over 2.5 clusters.</p>
<p>The final panel (Fig. 8D) shows average centrality metrics from function call networks, revealing a marked stability, except for numbers of terminal edges (in that context, meaning numbers of functions which call no other functions), which have decreased since around 2005 from around 12 per package to around 7.</p>
</div>
<div class="section level4">
<h4 id="sequential-releases-2">Sequential Releases<a class="anchor" aria-label="anchor" href="#sequential-releases-2"></a>
</h4>
<p>Analyses of sequential releases can only meaningfully be applied to the function call networks of Figs. 8C-D, and so Fig. 9 depicts equivalent values only for those two panels. Fig. 9A reveals that function call networks tend to become more densely connected as packages mature, and more so in <code>/src</code> than in <code>/R</code> directories. The aggregate increase contrasts strikingly with the equivalent and generally decreasing average tendency over time of Fig. 8C. This contrast can again be explained by the fact that most packages only have one or two releases, and so packages on CRAN have on average become less internally connected over time as recently-released packages have increasingly dominated. The decrease in package connectivity over one year of Fig. 8C corresponds to an equivalent increase in Fig. 9A after 224 releases, indicating that decreases in internal connectivity through increasing dominance of recently-released packages far outweighs compensatory decreases through packages maturing.</p>
<!--
Fig 8 but over package release instead of year
-->
<div class="figure">
<img src="figures/fig09.png" alt=""><p class="caption"><strong>Figure 9</strong> Network metrics from function call networks as a function of release sequence.</p>
</div>
<p>Finally, centrality metrics change dramatically as packages mature (Fig. 9B), in stark contrast to the annual changes of Fig. 8D. Packages develop greater numbers of terminal edges, yet retain almost identical vertex degrees through becoming more centralised as they develop. One way such an effect could be achieved would be through transforming a package from having several distinct clusters, each internally highly connected yet only loosely coupled to other clusters, progressing towards having fewer numbers of more highly centralised clusters, with increasing numbers of single connections out to terminal vertices.</p>
</div>
</div>
<div class="section level3">
<h3 id="code-formatting-and-documentation">Code formatting and Documentation<a class="anchor" aria-label="anchor" href="#code-formatting-and-documentation"></a>
</h3>
<p>We conclude these results with analyses generated by the internal Lines-of-Code routines of <code>pkgstats</code>, along with static analyses of the function documentation (<code>.Rd</code>) files. Proportions of blank and comment lines have remained markedly similar in both <code>/R</code> and <code>/src</code> directories over time, except for comment lines in <code>/R</code> code, which have increased dramatically since around 2010. This roughly corresponds to the first release of the <a href="https://roxygen2.r-lib.org/" class="external-link">roxygen2</a> package which has indubitably done more than any other package to standardise documentation of R functions. This increase in <code>/R</code> documentation is likely a direct reflection of the widespread adoption of <a href="https://roxygen2.r-lib.org/" class="external-link">roxygen2</a> as the documentation standard for R packages.</p>
<div class="figure">
<img src="figures/fig10.png" alt=""><p class="caption"><strong>Figure 10.</strong> Code formatting and documentation.</p>
</div>
<p>The relative proportion of white space in code lines has increased consistently yet very slightly over time, amounting to an increase from slightly under 13% to slightly over 14.5%. This value nevertheless describes average changes for every line of code, and so amounts to one additional space for every 67 code characters. The most dramatic development of Fig. 10B is clearly the decrease in the proportion of files with tab-indentation, from well over 60% before the year 2000 to barely over 10% today. Ignoring tabs, code indentation increased until around 2005-2010, remaining constant at 3-3.5 spaces for many years before more recently declining to well under 3 spaces.</p>
<p>Each R function in 1998 had an average of six parameters, yet this declined very rapidly to under four within two years (Fig. 10C). Numbers of parameters have progressively increased since then, yet still barely exceed an average of four parameters per function. Parameter documentation has followed an almost identical trend, increasing from under 70 characters per parameter to just over 80. In contrast, total numbers of documentation lines per function initially increased until around 2010, at almost 60 lines, before decreasing more recently to 50 lines per function or less.</p>
<p>The equivalent results analysed as a function of release sequence rather than year reveal that functions become markedly better documented as packages mature (Fig. 10D), although not through additional documentation of parameters. Analogous to preceding results, the recent decrease in documentation lines per function likely reflects an increasing prevalence of recently released packages which outweighs increases in function documentation as individual packages mature.</p>
<p>Finally, contrasting panels C and D of Fig. 10 also reveals a likely influence of increasing dominance of recent packages on numbers of parameters per function. While this number has increased consistently over recent years (Fig. 10C), numbers of parameters also decrease markedly as packages mature, equating to an average of one parameter fewer in all functions after 58 releases. The equivalent annual effect from Fig. 10C would translate to one additional parameter every 46 years. The average interval between package releases over the duration of CRAN has been 207 days, according to which 58 releases would take 33 years. That comparison suggests that the effects of packages maturing in decreasing average numbers of parameters per function (still) slightly out-competes the counteracting effect of increasing average numbers of parameters per function through the increasing dominance of recently released packages.</p>
</div>
</div>
<div class="section level2">
<h2 id="discussion">Discussion<a class="anchor" aria-label="anchor" href="#discussion"></a>
</h2>
<p>These results reveal a number of metrics which appear to have evolved in one direction when collectively measured across all CRAN packages, yet which tend to evolve in opposing directions within the evolution of individual packages. An example is the metric of “coupling instability” which has increased markedly for all packages since around 2010 (Fig. 6B), yet which decreases in any individual package from near one on first release (due to new packages being unable to be used or depended on by other packages) to near zero after around 100 releases. Additional examples arose in proportions of calls to base R functions, which have collectively decreased over time (Fig. 6A), from over 80 to under 70%, while calls to contributed packages have collectively increased from under 1% to almost 15% in 2021. While individual packages tend to use proportionally fewer calls to base R functions as they mature, they also use proportionally fewer calls to contributed packages, and substitute both of these with increasing proportions of calls to recommended packages (Fig. 7A). Simpler examples also arise in variables like numbers of R functions per file, which have decreased consistently over CRAN as a whole (Fig. 4D), yet which increase progressively as individual packages mature (Fig. 5D).</p>
<p>These general patterns indicate the ubiquity of a dual dynamic between individual packages tending to develop or evolve in one particular direction, yet CRAN as a whole collectively developing in opposing directions due to becoming increasingly dominated by less mature packages in relatively preliminary states of development. It is of course generally not straightforward for many metrics considered here to determine whether an observed trajectory might be a positive development for CRAN as a whole or not. The example of coupling instability nevertheless provides one metric with a clear understanding, and for which high values are generally considered undesirable <span class="citation">(Martin 2003)</span>. In this context at least, the ongoing development of CRAN is defined by a dynamic balance between the stabilising influence of mature packages, and converse and potentially destabilising influences of increasing numbers of recently contributed packages.</p>
<p>However, even balances between variables like these which are relatively easy to interpret must be considered carefully. For example, the preceding results made several comparisons through quantifying relative rates of change of such opposing tendencies. Direct comparisons presume more recent packages to have equal weight or influence on the overall system dynamic as do more mature packages. It may be more appropriate to implement some form of weighted analyses, for example, through weighting the contributions of individual packages by numbers of dependent packages. Although such analyses lie beyond the scope of the present work, the evident tensions between individual and collective dynamics represent a key finding of the present work, and one which could and should be extended in future analyses through considering such additional influences as weighted contributions of individual packages to the collective development of software systems.</p>
<div class="section level3">
<h3 id="quantifying-temporal-development-of-software-systems">Quantifying temporal development of software systems<a class="anchor" aria-label="anchor" href="#quantifying-temporal-development-of-software-systems"></a>
</h3>
<p>The preceding analyses contrasted and compared results derived from two distinct ways of quantifying “annual” statistics. The “snapshot” values considered the collective properties of the system as it existed in each year, including latest versions of all packages regardless of when those packages were last updated. In contrast, “annual” values only considered software actively uploaded in each year. As stated at the outset, snapshot values may be generally presumed to reflect exponentially-smoothed versions of annual values, and so these two approaches to aggregating annual values ought to qualitatively agree, with snapshots merely being an effectively smoothed version of annual values. Such an assertion can nevertheless never be more than a generalisation, and the particular statistical properties of a system may manifest different patterns.</p>
<p>Such contrasting patterns arose in the annual developments of Gini coefficients of Fig. 6C, which presented coefficients both for inequality between numbers of package dependencies, and numbers of individual functions from those dependencies. Calculating annual values only from software uploaded in each year (“annual” values; solid lines in that figure) yielded Gini coefficients which have progressively decreased over the last two decades, while using “snapshot” values produced opposing trajectories of increasing Gini coefficients (dashed lines).</p>
<p><span class="citation">Decan, Mens, and Grosjean (2019)</span> previously claimed that Gini coefficients for all seven package distribution systems they studied had increased over time. These coefficients measure relative inequality in the distributions of numbers of package imports, with larger values reflecting systems with greater disparities between packages in numbers of imports. While <span class="citation">Decan, Mens, and Grosjean (2019)</span> did not explicitly describe how they defined their annual figures, all data were derived from the “meta-platform” <code>libraries.io</code>, which collates software from several distribution systems and computer languages. Use of data from this platform would only enable “annual” rather than “snapshot” values to be calculated. The present results then appear to contradict theirs, through revealing annual Gini coefficients to have decreased over the preceding two decades, rather than increasing as they concluded (albeit in their case over a more narrow temporal range of 2012-2017). Quantifying annual values as snapshots of the entire system, including latest versions from all prior years, led to opposing trajectories of increasing Gini coefficients.</p>
<p>While detailed consideration of these differences lies beyond the scope of the present work, it is nevertheless important to note that for discrete, non-negative variables such as counts, Gini coefficients must generally increase with the scale or maximal values of those variables. Thus if average numbers of imported packages (or functions) increases over time, so should Gini coefficients. This consideration alone suggests that observations of <em>increasing</em> Gini coefficients should be interpreted cautiously, as they may merely reflect uniformly increasing dependence on external packages, while observations of <em>decreasing</em> Gini coefficients, as with out “snapshot” values, may reflect genuine changes. Whatever the underlying cause of these observed differences, they clearly reveal the critical importance of precisely specifying the methods used to aggregate annual values.</p>
</div>
<div class="section level3">
<h3 id="future-work">Future Work<a class="anchor" aria-label="anchor" href="#future-work"></a>
</h3>
<blockquote>
<p>we need better data to do computational statistics on statistical computing solutions: certainly, the CRAN package repository should be an extremely valuable resource for the community, both for gathering and analyzing such data.</p>
</blockquote>
<p><span class="citation">Hornik (2012)</span></p>
</div>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-mining-repos-2013" class="csl-entry">
Allamanis, Miltiadis, and Charles Sutton. 2013. <span>“Mining Source Code Repositories at Massive Scale Using Language Modeling.”</span> In <em>2013 10th Working Conference on Mining Software Repositories</em>, 207–16. <a href="https://doi.org/10.1109/MSR.2013.6624029" class="external-link">https://doi.org/10.1109/MSR.2013.6624029</a>.
</div>
<div id="ref-almugrin_coupling_2015" class="csl-entry">
Almugrin, Saleh, and Austin Melton. 2015. <span>“Indirect <span>Package</span> <span>Coupling</span> <span>Based</span> on <span>Responsibility</span> in an <span>Agile</span>, <span>Object</span>-<span>Oriented</span> <span>Environment</span>.”</span> In <em>2015 <span>Second</span> <span>International</span> <span>Conference</span> on <span>Trustworthy</span> <span>Systems</span> and <span>Their</span> <span>Applications</span></em>, 110–19. <a href="https://doi.org/10.1109/TSA.2015.26" class="external-link">https://doi.org/10.1109/TSA.2015.26</a>.
</div>
<div id="ref-pypi2019" class="csl-entry">
Bommarito, Ethan, and Michael Bommarito. 2019. <span>“An Empirical Analysis of the Python Package Index (PyPI).”</span> <em>arXiv</em> 1907.11073. <a href="https://arxiv.org/abs/1907.11073" class="external-link">https://arxiv.org/abs/1907.11073</a>.
</div>
<div id="ref-oss-evolution-2016" class="csl-entry">
Chahal, Kuljit Kaur, and Munish Saini. 2016. <span>“Open Source Software Evolution: A Systematic Literature Review (Part 1).”</span> <em>International Journal of Open Source Software and Processes (IJOSSP)</em> 7 (1): 28–45. <a href="https://doi.org/10.4018/IJOSSP.2016010101" class="external-link">https://doi.org/10.4018/IJOSSP.2016010101</a>.
</div>
<div id="ref-igraph" class="csl-entry">
Csardi, Gabor, and Tamas Nepusz. 2006. <span>“The Igraph Software Package for Complex Network Research.”</span> <em>InterJournal</em> Complex Systems: 1695. <a href="https://igraph.org" class="external-link">https://igraph.org</a>.
</div>
<div id="ref-ctan-wiki" class="csl-entry">
<span>“CTAN.”</span> 2021. <em>Wikipedia</em>. <a href="https://en.wikipedia.org/w/index.php?title=CTAN&amp;oldid=1049045588" class="external-link">https://en.wikipedia.org/w/index.php?title=CTAN&amp;oldid=1049045588</a>.
</div>
<div id="ref-dpkg" class="csl-entry">
Debian Policy Editors. 2021. <span>“3. <span>Binary</span> Packages — <span>Debian</span> <span>Policy</span> <span>Manual</span> V4.6.0.1.”</span> <em>Debian Policy Manual</em>. <a href="https://www.debian.org/doc/debian-policy/ch-binary.html" class="external-link">https://www.debian.org/doc/debian-policy/ch-binary.html</a>.
</div>
<div id="ref-decan_topology_2016" class="csl-entry">
Decan, Alexandre, Tom Mens, and Maelick Claes. 2016. <span>“On the Topology of Package Dependency Networks: A Comparison of Three Programming Language Ecosystems.”</span> In <em>Proccedings of the 10th <span>European</span> <span>Conference</span> on <span>Software</span> <span>Architecture</span> <span>Workshops</span></em>, 1–4. <span>ECSAW</span> ’16. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2993412.3003382" class="external-link">https://doi.org/10.1145/2993412.3003382</a>.
</div>
<div id="ref-decan_development_2015" class="csl-entry">
Decan, Alexandre, Tom Mens, Maelick Claes, and Philippe Grosjean. 2015. <span>“On the <span>Development</span> and <span>Distribution</span> of <span>R</span> <span>Packages</span>: <span>An</span> <span>Empirical</span> <span>Analysis</span> of the <span>R</span> <span>Ecosystem</span>.”</span> In <em>Proceedings of the 2015 <span>European</span> <span>Conference</span> on <span>Software</span> <span>Architecture</span> <span>Workshops</span></em>, 1–6. <span>ECSAW</span> ’15. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2797433.2797476" class="external-link">https://doi.org/10.1145/2797433.2797476</a>.
</div>
<div id="ref-decan_when_2016" class="csl-entry">
Decan, Alexandre, Tom Mens, Maëlick Claes, and Philippe Grosjean. 2016. <span>“When <span>GitHub</span> <span>Meets</span> <span>CRAN</span>: <span>An</span> <span>Analysis</span> of <span>Inter</span>-<span>Repository</span> <span>Package</span> <span>Dependency</span> <span>Problems</span>.”</span> In <em>2016 <span>IEEE</span> 23rd <span>International</span> <span>Conference</span> on <span>Software</span> <span>Analysis</span>, <span>Evolution</span>, and <span>Reengineering</span> (<span>SANER</span>)</em>, 1:493–504. <a href="https://doi.org/10.1109/SANER.2016.12" class="external-link">https://doi.org/10.1109/SANER.2016.12</a>.
</div>
<div id="ref-seven-pkg-networks-2019" class="csl-entry">
Decan, Alexandre, Tom Mens, and Philippe Grosjean. 2019. <span>“An Empirical Comparison of Dependency Network Evolution in Seven Software Packaging Ecosystems.”</span> <em>Empirical Software Engineering</em> 24: 381–416. <a href="https://doi.org/10.1007/s10664-017-9589-y" class="external-link">https://doi.org/10.1007/s10664-017-9589-y</a>.
</div>
<div id="ref-network-centrality-79" class="csl-entry">
Freeman, Linton C. 1978. <span>“Centrality in Social Networks Conceptual Clarification.”</span> <em>Social Networks</em> 1 (3): 215–39. https://doi.org/<a href="https://doi.org/10.1016/0378-8733(78)90021-7" class="external-link">https://doi.org/10.1016/0378-8733(78)90021-7</a>.
</div>
<div id="ref-german_evolution_2013" class="csl-entry">
German, Daniel M., Bram Adams, and Ahmed E. Hassan. 2013. <span>“The <span>Evolution</span> of the <span>R</span> <span>Software</span> <span>Ecosystem</span>.”</span> In <em>2013 17th <span>European</span> <span>Conference</span> on <span>Software</span> <span>Maintenance</span> and <span>Reengineering</span></em>, 243–52. https://doi.org/<a href="https://doi.org/10.1109/CSMR.2013.33" class="external-link">https://doi.org/10.1109/CSMR.2013.33</a>.
</div>
<div id="ref-npm-2020" class="csl-entry">
Goldwater, Matt. 2020. <span>“An Abbreviated History of <span>JavaScript</span> Package Managers.”</span> <em>Medium</em>. <a href="https://javascript.plainenglish.io/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e" class="external-link">https://javascript.plainenglish.io/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e</a>.
</div>
<div id="ref-macro-evolution-2009" class="csl-entry">
Gonzalez-Barahona, Jesus M., Gregorio Robles, Martin Michlmayr, Juan José Amor, and Daniel M. German. 2009. <span>“Macro-Level Software Evolution: A Case Study of a Large Software Compilation.”</span> <em>Empirical Software Engineering</em> 14: 262–85. <a href="https://doi.org/10.1007/s10664-008-9100-x" class="external-link">https://doi.org/10.1007/s10664-008-9100-x</a>.
</div>
<div id="ref-new-pypi-2018" class="csl-entry">
Harihareswara, Sumana. 2018. <span>“A New Package Index for <span>Python</span> [<span>LWN</span>.net].”</span> <em>A New Package Index for Python</em>. <a href="https://lwn.net/Articles/751458/" class="external-link">https://lwn.net/Articles/751458/</a>.
</div>
<div id="ref-hornik_too_many_R_pkgs_2012" class="csl-entry">
Hornik, Kurt. 2012. <span>“Are <span>There</span> <span>Too</span> <span>Many</span> <span>R</span> <span>Packages</span>?”</span> <em>Austrian Journal of Statistics</em> 41 (1): 59–66. <a href="https://doi.org/10.17713/ajs.v41i1.188" class="external-link">https://doi.org/10.17713/ajs.v41i1.188</a>.
</div>
<div id="ref-software-evolution-97" class="csl-entry">
Lehman, M. M., J. F. Ramil, P. D. Wernick, D. E. Perry, and W. M. Turski. 1997. <span>“Metrics and Laws of Software Evolution-the Nineties View.”</span> In <em>Proceedings Fourth International Software Metrics Symposium</em>, 20–32. <a href="https://doi.org/10.1109/METRIC.1997.637156" class="external-link">https://doi.org/10.1109/METRIC.1997.637156</a>.
</div>
<div id="ref-martin-agile-2002" class="csl-entry">
Martin, Robert C. 2003. <em>Agile Software Development, Principles, Patterns, and Practices</em>. Upper Saddle River, N.J.: Prentice-Hall.
</div>
<div id="ref-Mens2008" class="csl-entry">
Mens, Tom. 2008. <span>“Introduction and Roadmap: History and Challenges of Software Evolution.”</span> In <em>Software Evolution</em>, 1–11. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="https://doi.org/10.1007/978-3-540-76440-3_1" class="external-link">https://doi.org/10.1007/978-3-540-76440-3_1</a>.
</div>
<div id="ref-mora-cantallops_complex_2020" class="csl-entry">
Mora-Cantallops, Marçal, Salvador Sánchez-Alonso, and Elena García-Barriocanal. 2020. <span>“A Complex Network Analysis of the <span>Comprehensive</span> <span>R</span> <span>Archive</span> <span>Network</span> (<span>CRAN</span>) Package Ecosystem.”</span> <em>Journal of Systems and Software</em> 170 (December): 110744. <a href="https://doi.org/10.1016/j.jss.2020.110744" class="external-link">https://doi.org/10.1016/j.jss.2020.110744</a>.
</div>
<div id="ref-pkg-mngrs-2018" class="csl-entry">
Ovens, Steve. 2018. <span>“The Evolution of Package Managers.”</span> <em>Opensource.com</em>. <a href="https://opensource.com/article/18/7/evolution-package-managers" class="external-link">https://opensource.com/article/18/7/evolution-package-managers</a>.
</div>
<div id="ref-static-analysis-2016" class="csl-entry">
Papamichail, Michail, Themistoklis Diamantopoulos, and Andreas Symeonidis. 2016. <span>“User-Perceived Source Code Quality Estimation Based on Static Analysis Metrics.”</span> In <em>2016 IEEE International Conference on Software Quality, Reliability and Security (QRS)</em>, 100–107. <a href="https://doi.org/10.1109/QRS.2016.22" class="external-link">https://doi.org/10.1109/QRS.2016.22</a>.
</div>
<div id="ref-plakidas_evolution_2017" class="csl-entry">
Plakidas, Konstantinos, Daniel Schall, and Uwe Zdun. 2017. <span>“Evolution of the <span>R</span> Software Ecosystem: <span>Metrics</span>, Relationships, and Their Impact on Qualities.”</span> <em>Journal of Systems and Software</em> 132 (October): 119–46. <a href="https://doi.org/10.1016/j.jss.2017.06.095" class="external-link">https://doi.org/10.1016/j.jss.2017.06.095</a>.
</div>
<div id="ref-syeed_evolution_2013" class="csl-entry">
Syeed, Mahbubul, Imed Hammouda, and Tarja Syatä. 2013. <span>“Evolution of <span>Open</span> <span>Source</span> <span>Software</span> <span>Projects</span>: <span>A</span> <span>Systematic</span> <span>Literature</span> <span>Review</span>.”</span> <em>Journal of Software</em> 8 (11): 2815–29. <a href="https://doi.org/10.4304/jsw.8.11.2815-2829" class="external-link">https://doi.org/10.4304/jsw.8.11.2815-2829</a>.
</div>
<div id="ref-Turski96" class="csl-entry">
Turski, W. M. 1996. <span>“Reference Model for Smooth Growth of Software Systems.”</span> <em>IEEE Transactions on Software Engineering</em> 22 (08): 599–600. <a href="https://doi.org/10.1109/TSE.1996.10007" class="external-link">https://doi.org/10.1109/TSE.1996.10007</a>.
</div>
<div id="ref-Turski02" class="csl-entry">
———. 2002. <span>“The Reference Model for Smooth Growth of Software Systems Revisited.”</span> <em>IEEE Transactions on Software Engineering</em> 28 (8): 814–15. <a href="https://doi.org/10.1109/TSE.2002.1027802" class="external-link">https://doi.org/10.1109/TSE.2002.1027802</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Mark Padgham.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.2.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
