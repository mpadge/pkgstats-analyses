---
title: "Historical Trends in R Package Structure and Interdependency on CRAN"
author: "Mark Padgham & Noam Ross"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        number_sections: true
        theme: flatly
bibliography: pkgstats.bib
header-includes: 
    - \usepackage{tikz}
    - \usetikzlibrary{arrows}
vignette: >
  %\VignetteIndexEntry{pkgstats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r pkg-load, echo = FALSE, message = FALSE}
library (pkgstatsAnalyses)
library (ggplot2)
library (patchwork)
library (dplyr)
library (tidyr)
library (igraph)
here <- here::here ()
v_data_dir <- file.path (here, "vignettes", "data")
if (!dir.exists (v_data_dir))
    dir.create (v_data_dir, recursive = TRUE)
logmean <- function (x, ...) {
    10 ^ mean (log10 (x [which (x > 0)]), na.rm = TRUE)
}
```

```{r dl-data, echo = FALSE}
path <- file.path (here, "data-raw")
if (!dir.exists (path)) {
    dir.create (path, recursive = TRUE)
}

u <- paste0 ("https://github.com/mpadge/pkgstats-analyses/",
             "releases/download/v0.0.1/")

f_r <- file.path (path, "pkgstats-results.Rds")
if (!file.exists (f_r)) {
    u_r <- paste0 (u, "pkgstats-results.Rds")
    download.file (u_r, f_r)
}

f_p <- file.path (path, "pypi.Rds")
if (!file.exists (f_p)) {
    u_p <- paste0 (u, "pypi.Rds")
    download.file (u_p, f_p)
}
```


# Introduction

A key component of the success of Open Source Software (OSS) is package
managers [@pkg-mngrs-2018], which effectively serve as curated repositories of
independently-contributed software. Package managers exist both for specific
operating systems [@pkg-mngrs-2018] and specific computer languages such as
python [@new-pypi-2018], LaTeX [@ctan-wiki], JavaScript [@npm-2020], and many
others. This work analyses all current and historically archived packages in
the CRAN (Comprehensive R Archive Network) package manager for the R language.

The majority of prior work on the temporal development or evolution of software
has been based on individual pieces of software, here generically referred to
as "packages". One notably exception is a recent analysis of the "pypi" (Python
Package Index) package manager for python [@pypi2019], which analysed and
presented a number of statistics relevant to the present work, including:

- Compound annual growth rates in numbers of new packages were slightly less
  (at 43%) than growth in active packages (47%) and in new releases (51%).
- Compound annual growth rates in numbers of new package authors was lower than
  these, at 39%.
- Each package has around 7 +/- 19 new releases per year, at an average
  inter-release frequency of 65 +/ 144 days.
- Each author has 2 +/- 17 packages, and 15 +/ 125 releases.
- Median package sizes are 20-40 KB, while mean values are 2-20 MB.
- Total numbers of imported packages increases with compound annual growth rate
  of 62%.
- The standard python libraries represent around 19% of all package imports.

This analyses represents the most comprehensive analysis to date of a package
manager for any computer language, drawn almost two million releases of 179,000
packages. The size of pypi necessarily restricted these analyses to package
metadata, although single metrics of package size were also included. Moreover,
the size of pypi meant that analyses of dependency networks were also
relatively restricted to aggregate statistics only, with no analyses of the
internal properties of dependency networks.

More detailed considerations of temporal development and evolution of code have
largely been restricted to individual packages. Analyses of code evolution
frequently refer to work of @software-evolution-97, who expressed their
findings as a series of "laws" of software evolution. These "laws" include
that, over time, software increases both in complexity and in functional
content (or numbers of functions). Those laws of growth themselves derive from
@Turski96, who posited an inverse-square law for software growth, later
formalised in @Turski02.

This inverse-square "law" was nevertheless an empirical fitting exercise only,
and merely posits the arguably simplest form for a process in which the rate of
growth of a system decreases as the system grows. There is no theoretical
reasons why software evolution should follow such a trajectory, nor do there
appear to have been either any examinations of alternative models of growth, or
of plausible theoretical foundations for any particular model.

These "laws" of software evolution have nevertheless been frequently used and
cited (see overview in @Mens2008, and references therein), although
overwhelmingly for considerations of individual software packages. They have
been widely adopted in a burgeoning field of what might be referred to as
"Software Mining and Analytics", to elucidate useful predictors of software
quality. A useful overview of the field was provided by @mining-repos-2013, who
usefully identified a number of categories, including that of "code statistics"
examined here.

More detailed considerations of package dependency networks have been developed
in more restricted, and thus more manageable, contexts, such as the analysis of
the Debian network of @macro-evolution-2009, which revealed progressive
increases in package inter-dependencies. Although they observe increases in the
sizes of packages over time, and claim that this reflects the laws of
@software-evolution-97, they neither quantify nor model actual rates of change.  <!-- do we or do we plan to? -->
They also observe that the relative sizes of packages, measured in terms of
lines of code, remains relatively stable across releases.

A more extensive consideration of dependency networks alone was provided by 
@seven-pkg-networks-2019, who examined networks from seven package management
systems, including pypi and CRAN. They observe
that both numbers of packages and numbers of dependencies increase more slowly
for CRAN packages than for any of the other systems they consider, as do
numbers of package updates. They also observe that the "survival probability"
(that a package is not updated at some time, $t$) <!-- This seems to be reversed? --> is far greater for CRAN than
for other package ecosystems (although with differences observed between
packages which are not required by other packages, and those which are).
Finally, they observe that the Gini coefficient of inequality between dependent
packages has also increased over time in all systems.

This work focusses on the CRAN package system which is around one tenth the
size of pypi for the python language, although still amounting to over 100,000
releases of around 20,000 packages. This smaller sizes enables far more
detailed analyses than previous work, not just of package metadata, but also
extending to detailed analyses of the code itself.

First, we describe the `{pkgstats}` R package, which can be used to generate
and analyze properties of R package code, and the accompanying database of code
statistics of all historical CRAN packages.  We then describe trends in CRAN
R package properties over the history of the archive (199X-2021).  We focus on
trends in four areas: Package metadata (licenses, authorship, translation),
Package and content (file and function types and sizes), intra-package code
structure (function call networks), and finally, dependency networks amongst
packages. Finally, we discuss implications and likely drivers of these trends,
and potential further applications and extensions of the `pkgstats` package
and database.

# Methods

<!-- This section should be way longer. It shoule
- described pkgstats package in more detail, to the point of basic usage
- describe the different metrics collected - if not a full list, then at least
  categories and a reference to a full list
- describe the usage of `ctags` and generation of relevant network statistics
- describe the availability of the full package database and where to download
  it
-->

Data in this study were generated by the [the R package,
`pkgstats`](https://docs.ropensci.org/pkgstats/), which we developed to
quantify the structure and content of R packages using static code analysis
techniques [@static-analysis-2016]. That package [includes a function,
`pkgstats_from_archive`](https://docs.ropensci.org/pkgstats/reference/pkgstats_from_archive.html),
which can be applied to a local mirror of the CRAN archive to collate
statistics from all packages. This methodological description begins with an
overview of data sources used, followed by a description of two open-source
libraries for "code tagging" used in the `pkgstats` package. We then describe
the package itself, before providing details of statistical analyses.

## Data: R packages and the CRAN server

Our primary data source comprised every version of every R package hosted on
the "Comprehensive R Archive Network" or CRAN, which is the centralised
distribution system for R packages. The `R` language itself is defined by a
single "package" referred to as "base R". By default, all installations of `R`
also [include a suite of "recommended"
packages](https://github.com/wch/r-source/tree/trunk/src/library). All other
packages are referred to as "Contributed Packages". A number of the following
results distinguish between base, recommended, and contributed code or
packages.

CRAN currently holds close to 19,000 contributed packages, and also maintains a
complete archive of all previous versions of all packages, including of
archived packages no longer available on CRAN. The data analysed here were
generated from a local mirror of the entire CRAN repository, including all
current and archived packages, and amounting to around 105,000 packages (for an
average of slightly over 5 releases per package). The raw data for these
analyses are the contributed packages themselves. While relationships to
objects (functions) in the base and contributed packages are considered, the
structure of the base and recommended packages is not analysed here.

All R packages accord with the structure defined in the ["*Writing R
Extensions*"
Manual](https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages)).
Many aspects of the following analyses were applied to different components of
R packages, in particular the following main sub-directories:

- The `/R` directory which holds all source files in the R language;
- The `/src` directory which holds all code in other languages which needs to be compiled on package installation;
- The `/inst` directory which generally holds bundles of external code, but may
  also include code used for cross-linking in compilation, including of other
  packages. Cross-linked code must be in an `/inst/include` sub-directory (as
  explained in [this section of the "*Writing R Extensions*"
  Manual](https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages)).
  All of the following analyses only consider the `/inst/include` directory, and
  all references to the `/inst` directory imply this sub-directory only.
  Analyses excluded all other sub-directories within the `/inst` directory.
- The `/vignettes` directory which includes extended documentation. (Such
  documentation may also be placed in an `/inst/doc` folder, but this was
  ignored here.)
- The `/tests` directory containing test files.
- The `/data` directory containing data files used to implement or demonstrate
  package functionality.

The results which follow also distinguish between the two main kinds of R
functions:

- Exported functions intended to be called by users of a package.
- Non-exported functions intended only to be called internally by other
  functions of a package.


## Code tagging with "ctags" and "gtags"

The `pkgstats` package is a static code analysis tool specifically developed
for R packages, with much of the functionality extending from two general
static analysis tools. Static code analysis tools generally work by
constructing parse trees which relate a grammar describing one or more computer
languages to each expression encountered by tracing the code. An important
first step is to "tag" each expression, identifying the kind of expression and
its scope (generally its membership either of some component of the underlying
grammar, or some more local scope such as definitions within locally-sourced
files).

The `pkgstats` package uses two open-source libraries for code tagging and
parse tree construction: "ctags" and "gtags". The original "ctags" library is
no longer maintained, and these analyses used a maintained version called
["Universal ctags"](https://ctags.io) which,

> generates an index (or tag) file of language objects found in source files
> for programming languages.

This library was used here to tag each expression in the `R`, `src`, and
`inst/include` directories, providing the following data for each tagged item:

1. The tag itself, such as the name of a function, variable, or other object;
2. The name of the corresponding file;
3. The full content of the expression in which that tag was used (as a text string);
4. The kind of object (in `R` files, generally a `function`, `functionVar` or
   variable defined within a function, `globalVar` for global variables, or
   other objects defined by the `R` language; kinds of objects can be
   arbitrarily diverse in other languages);
5. The computer language in which that object was referenced; and
6. The start and end line numbers of the file in which that object is defined
   or referenced.

The "ctags" data for R files were also used to construct an "external call
network" of references to all R functions in all packages, including the
package being analysed, the base and recommended packages, and all other
contributed packages imported by each package. Functions were attributed to
packages by matching function names. Function names in R do not have to be
unique, and "namespace conflicts" may arise between packages implementing
different functions with the same name. We presumed that namespace conflicts
most commonly arise in re-definitions of functions initially defined in base or
recommended packages, and in all such cases we attributed a function to the
external or contributed package over base or recommended definitions.

The "gtags" library, itself part of the [GNU Global
library](https://www.gnu.org/software/global/), generates entries for every
expression, with the "tag" itself defining the environment for that expression.
This enables mappings to be made between every expression and its corresponding
tag. We used "gtags" to construct object reference networks across all computer
languages used in R packages (such as C, C++, or Python), to enable the
construction of "function call networks" within and between all languages.
While the terms "functions" and "calls" may not be appropriate for all computer
languages and/or classes or types of objects, they nevertheless reflect the
functionality of R code, and so are preferred here, even when referring to
other object relationships such as class inheritance mechanisms.

It is possible to cross-compile "gtags" with "ctags", to enable "gtags" to use
the more expansive language parsing abilities of "ctags", and to greatly extend
the range of languages able to be parsed by "gtags". In particular, "gtags"
does not not by default parse R code, yet does so when cross-compiled with
Universal "ctags". Cross-compiled installations of "gtags" are, however,
generally several times slower than simpler installations, and so these
analyses did not use a cross-compiled version. While this meant restricting
analyses to a smaller subset of potential languages, the output of "ctags"
itself nevertheless describes tags in all possible languages, with "gtags" only
used to map function call networks in languages other than R. Function-call
networks within R were extracted from the "ctags" output as described above,
and one additional function was written to link calls within R code as defined
by the "ctags" output to external objects defined in other languages and
specified by the "gtags" output. This enabled full function-call networks to be
constructed within and between different languages used in R packages. Several
properties of these networks were analysed as described below.

Data generated by "ctags" and "gtags" which were analysed here included:

- Numbers of internal and external functions in R.
- Numbers and kinds of all objects in all other languages.
- Numbers of Lines-of-Code for each function or object definition in each language.
- References from each function (or object) make to all other functions (or
  objects), including references made to all functions defined in other base,
  recommended, or contributed R packages.



## The `pkgstats` package

This sub-section describes additional data generated by `pkgstats` beyond that
extracted from "ctags" and "gtags". The full list of all data generated by the
package is given in [the online
documentation](https://docs.ropensci.org/pkgstats/), with this sub-section only
describing those aspects which were analysed here.

### 'DESCRIPTION' files

All R packages must include a [Debian Control
File](https://www.debian.org/doc/debian-policy/ch-controlfields.html) ("DCF")
called "DESCRIPTION" which contains a subset of standard DCF fields, including
[a number of standardised and mandatory
fields](https://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file)
able to be analysed here. We extracted:

- Numbers of authors (as individuals with a specified role of "aut");
- Numbers of contributors (as individuals with a specified role of "ctb");
- Full entries of the "License" field specifying the type of license under
  which the software was released; and
- Entries in the "URL" field specifying one or more Uniform Resource Locators
  (URLs) for the package.
- Lists of all imported packages used to construct dependency networks between
  packages. (Neither required nor suggested packages were considered here.)

### Translation files

R packages may include [files used to translate all messages issued by code into
other (human)
languages](https://cran.r-project.org/doc/manuals/R-exts.html#Preparing-translations).
These files are placed in a dedicated `/po` sub-directory, with file names
prefixed with standard prefixes (generally, but not necessarily, [ISO 639-1
codes](https://en.wikipedia.org/wiki/ISO_639-1)). This format enables
translations to be readily identified and extracted. `pkgstats` extracts a list
of all translations provided for each package.

### Lines of Code (LoC)

`pkgstats` includes its own internal tool (coded in C++) for analysing
Lines-of-Code (Loc). This tool produces output similar to many common LoC
tools, with additional data on:

1. Total numbers of code, comment, and blank lines;
2. Total numbers of characters in code lines, along with total numbers of
   white-space characters, to enable metrics of proportional white space; and
3. Code indentation, including identification of tab-indentation.

### Function-level analyses

The "ctags" and "gtags" output described above provides data on the start and
end points of each function definition, along with names of associated files.
These data were used to provide estimates of average LoC per function, and
numbers of function definitions per file. (Where, as explained above,
"function" is used here as generic label for any object in any language, such
as class definitions.)

Each exported function in an R package must have a corresponding documentation
file in the `/man` directory of the package with the suffix, `.Rd` for "R
documentation". `pkgstats` also statically parses these files with [the
`parse_Rd` function of the recommended `tools`
package](https://stat.ethz.ch/R-manual/R-devel/library/tools/html/parse_Rd.html).
For the present analyses, this enabled identification of the number of
parameters for each function, and the number of documentation characters for
each parameter. Total length of documentation for each function was also
quantified as the number of lines in the output produced by converting the
result of `parse_Rd` to text (via the `tools::Rd2txt` function).


## Network Analyses

Two distinct kinds of network analysis were performed here: *inter-package*
analyses of dependency networks between packages (akin to
@seven-pkg-networks-2019), and *intra-package* analyses of the function call
networks extracted from the "ctags" and "gtags" data described above.

### Inter-Package Network Analyses

The 'DESCRIPTION' files of R packages must specify all external packages which
a package imports. These data can be used to construct a full dependency
network of all packages. The results below present the following measures
derived from package dependency networks, all of which were calculated with the
`igraph` package [@igraph].

1. Numbers of packages which are not imported by any others - the terminal
   vertices in a dependency network; 
2. Average "in-degree" of network vertices, or average numbers of times each
   package is imported by others;
3. The average *betweenness centrality* of each edge, which is the number of
   times that edge is traversed in connecting every package to every other
   package in the network;
4. The network-level *degree centrality*, which is a measure of vertex degree
   standardised to the overall size and structure of the network
   (@network-centrality-79).
5. A measure of the overall "size" of the network as the average distance
   between all pairs of vertices.

Betweenness centrality provides insight into how centralised the network is,
with higher values reflecting networks in which connections frequently traverse
a common, central region. The network-level degree centrality reflects the
extent to which vertices all have a relatively high in-degree; networks in
which all networks have an equal in-degree have no effective centre, and so
have a degree centrality of zero. In contrast, networks with a few
highly-connected central vertices and many vertices with low in-degree will
have a high degree centrality. These two centrality metrics provide slightly
different insights: betweenness centrality will increase to the extent to which
a network manifests a single, common centre; degree centrality will increase to
the extent that networks become more centralised in general, regardless of
whether or not any singly identifiable centre forms.

Networks with low degree centrality are readily traversable, and so will
generally have lower average distances between all pairs of vertices. The
distance metric nevertheless may offer additional insight, and will for example
be higher independent of degree centrality for networks with extended
peripheral connections. Finally, we note that clusters or local network
communities were not considered here, as the dependency networks of CRAN
packages are almost always so highly connected that the largest connected
cluster represents over 99% of the network.

### Intra-Package Network Analyses

Intra-package networks were constructed from the function call networks
described above, and included overall package networks connecting code in all
sub-directories, as well as network analyses of only those components
representing individual sub-directories, here constrained to network analyses
of both `/R` and `/src` code. Function call networks within individual packages
are commonly structured in several distinct clusters, and thus numbers of
clusters provided an important first metric for intra-package analyses.
Intra-package analyses considered the following metrics:

1. Ratio of numbers of edges to numbers of vertices.
2. Numbers of distinct clusters between all functions or objects across all
   languages.
3. The betweenness centrality of the function call network.
4. Numbers of terminal vertices (functions which do not call any other
   functions).
5. The average vertex degree.


## Coupling Instability

[Coupling Instability](https://en.wikipedia.org/wiki/Software_package_metrics)
is an important concept in the analysis of software dependency networks
[@martin-agile-2002], and depends in turn on numbers of so-called *afferent*
and *efferent* couplings. For any given packages, these are defined as:

- *Afferent Couplings* as numbers of functions in other packages which depend
  on functions within the package.
- *Efferent Couplings* as numbers of functions from other packages which the
  package depends on.

*Afferent* couplings are numbers of *inbound* edges from all other packages to
a given package, while *efferent* couplings are *outbound* edges coupling that
package with all other packages. Respectively denoting afferent and efferent
couplings by $n_a$ and $n_e$, the coupling instability, $I$, is then defined as
$I = n_e / (n_e + n_a)$. Packages which depend on many external calls (high
efferent couplings), yet upon which few other packages depend (low afferent
couplings) thus have a high coupling instability, while packages upon which
many other packages depend, yet which themselves depend on few other packages
have a low coupling instability. The analyses below quantified coupling
instability for each package from the dependency networks, using total numbers
of function calls between all packages, in order to estimate the average
coupling instability of the entire network.

## Statistical Analyses

The following results depict and interpret qualitative trends and patterns,
without reporting on any statistical tests. In frequentist terms, data were
sufficiently large ($N > 105,000$) to ensure that all of the reported results,
were they to be analyses as linear relationships, were entirely significant.
There are two further important aspects to note in regard to statistical
analyses detailed below.

### Temporal Analyses

Most of the following results depict the evolution of CRAN software over time,
in two main ways:

1. As annual developments averaged over all packages; or
2. As developments for individual packages over sequences of releases.

Several of the following results are divided into the corresponding
sub-sections of "Annual Developments" and "Sequential Releases," respectively
referring to these two modes of analysis. Annual developments aggregate values
over all packages for each year, while sequential developments aggregate values
over each sequential release, so that the first versions of all packages are
aggregated for a release sequence of one, second versions for release sequence
two, and so on.

For continuously updated repositories like CRAN, annual developments can be
captured in the following two primary ways:

1. Through considering each year to represent the state of CRAN at that time,
   and thus to include latests releases of all packages for that year,
   regardless of how long ago a package may previously have been updated.
   Annual estimates derived this way are referred to here as **CRAN
   snapshots**.
2. Through considering each year to represent only the state of CRAN in terms
   of packages uploaded in that specific year, disregarding any packages
   uploaded in prior years. Estimates derived this way are referred to simply
   as **annual** values.

Under the plausible assumption that rates of package updates follow some kind
of Poisson-like process, the ages of packages at any given time will be
exponentially distributed, analogous to distributions of waiting times for
Poisson processes. This means that values derived using **CRAN snapshots** will
generally reflect exponentially-smoothed versions of **annual** values. Many of
the graphical results which follow depict results dervied using both of these
approaches, in which:

- solid lines represent annual values, which are generally noiser versions of
- dashed lines, which represent effectively exponentially-smoothed versions of
  the same data using CRAN snapshots for each year.

Where no additional interpretations are given, solid lines in all of the
results that follow represent annual values, while dashed lines represent
results derived from CRAN shapshots. See Fig. 1A immediately below, for an
example. Where also not otherwise mentioned, all reported values refer to
annual values, and not to values derived from CRAN snapshots.


### Distributional properties and mean values

Almost all statistics described above, and presented in the results below, were
approximately log-normally distributed. References in any of the following
results to mean values thus imply values calculated as `10^mean(log10(x))`. The
use of direct mean values did not generally alter any of the qualitative
conclusions which follow, yet resulted in many cases in less distinct or smooth
trajectories or results.

# Results

## Metadata

The relatively regulated process of CRAN submissions [@seven-pkg-networks-2019]
is reflected in more regulated meta-data able to be extracted from package
'DESCRIPTION' files. Numbers of both authors and contributors have increased
over time (Fig. 1A), with contributors having been rarely acknowledged at all
prior to 2010 (two years after the launch of GitHub), increasing to an average
of one acknowledged contributor per package in 2021.

Numbers of unique licenses primarily reflect numbers of ways of declaring
licenses, rather than actual numbers of licenses. Figure 1B shows a roughly
linear increase in license declarations up to around 2007, followed by a
pronounced drop and progression into a roughly stable range of somewhere over
50 distinct entries. The different ways of specifying the three versions of GPL
licenses have accounted for over 83% of all CRAN packages, with the second most
common type license being MIT, at 9.6%, followed by BSD at 2.0%. One of these
three licenses are used in 95% of all CRAN packages.


```{r fig01, child = "figures/fig01.Rmd", eval = TRUE, echo = FALSE}
```

```{r licenses, echo = FALSE}
datafile <- file.path (here, "data-raw", "pkgstats-results.Rds")
x <- load_pkgstats_data (datafile, raw = TRUE, latest = FALSE)
index <- which (x$year > 2010)
lic <- sort (table (x$license [index]), decreasing = TRUE)
lic <- data.frame (license = names (lic),
                   n = as.integer (lic))
#knitr::kable (lic [1:10, ], caption = "**Table 1.**")

index <- grep ("GPL|general\\spublic\\slic", lic$license)
prop_gpl <- sum (lic$n [index]) / sum (lic$n)
index <- grep ("BSD", lic$license)
prop_bsd <- sum (lic$n [index]) / sum (lic$n)
index <- grep ("MIT", lic$license)
prop_mit <- sum (lic$n [index]) / sum (lic$n)
prop3 <- prop_gpl + prop_bsd + prop_mit
```

The practice of translating messages within R packages into other languages has
steadily declined in recent years (Fig. 2A), suggesting a pronounced increase
in acceptance over the last 15 or so years of English as a globally standard
language, and a concomitant decrease in active acknowledgement of other
languages. (The `en@quot` translation entry is described in the [*R
Installation and Administration*
Manual](https://cran.r-project.org/doc/manuals/R-admin.html#Localization-of-messages)
as a translation which, "can be used in a UTF-8 locale to have American error
messages with pairs of single quotes translated to Unicode directional
quotes.") Rates of decrease since 2008 equate to 1.5% fewer packages per year
including translations, from a total of just over 20% of all packages in 2008,
to barely over 1% in 2021. While rates of decreased have slowed somewhat in
recent years, extrapolation of the preceding five years nevertheless suggests
that the practice of offering translations will entirely disappear by 2023.

```{r fig02, child = "figures/fig02.Rmd", eval = TRUE, echo = FALSE}
```


Analyses of URLs provided in package 'DESCRIPTION' files clearly reveals an
abrupt break after around 2010 with the advent of online code repositories
(Fig. 2B). GitHub has always dominated, while r-forge has declined
progressively since around 2015. The most notable increase has been the
emergence of rOpenSci as provider of the only URL to come close to within
1/20th of the popularity of GitHub over the past few years.


## Package Structure and Content

The temporal development of numbers of files manifest several notable
characteristics (Figure 3). Unsurprisingly, R packages have always been
dominated by files in the `R/` directory, numbers of which increased
considerably up to around 2010, after which they are generally stabilised at a
mean value of around 20 files (Fig. 3A). The `data` and `vignettes` directories
are the only places within R packages in which numbers of files have remained
relatively constant over the preceding 20+ years. Packages generally had very
few files in the `inst` directory prior to 2010, after which they increased
until around 2015, before decreasing again more recently. The two
sub-directories in which numbers of files have increased most significantly are
`src` and `tests`, with the latter increase particularly distinct, clearly
indicating that packages have become progressively better tested.


```{r fig03, child = "figures/fig03.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Figure 3B shows equivalent relative changes within individual packages across
successive releases. The changes there are proportional changes in numbers of
files in each of the nominated directories, starting with the change between
the second and first release (a "Release sequence" of 2). Although numbers of
files generally increase with each new release, *rates* of increase tend to
slow down, with packages approaching stability (a ratio of 1) after around 20
releases. Throughout these first 20 releases, numbers of test files generally
increase at a greater rate than numbers of files in any other directory,
further indicating that not only have packages become better tested over time
on average (Fig. 2A), but that individual packages tend to become better tested
with each successive release.



## Code Metrics

### Annual Developments

Figure 4 shows the temporal evolution of a number of code metrics. These
figures distinguish between the two primary kinds of R functions, exported and
non-exported, and also between the main sub-directories of R packages described
at the outset. Lines of Code ("LoC") in the primary `/R` and `/src` directories
broadly increased up to around 2005-2010, after which time LoC in these
directories has slightly decreased, converging on just over 600 lines in both
`/R` and `/src` directories. These trends are broadly reflected in LoC per
function (Fig. 4B), excepting the early years of CRAN, during which functions
often had well over 100 lines each, especially `src` functions defined in other
languages (in those years, primarily Fortran and C). LoC per function have
remained broadly stable for almost 20 years, at around 30 lines for all
function types and languages. The slight decrease discernible since around 2015
amounts to one LoC less for exported, non-exported, and `/src` functions every
3.4, 8.5, and 1.5 years, respectively.

Total numbers of R functions initially increased until around 2007, peaking at
just under 30 exported and over 50 non-exported functions per package (Fig.
4C). Numbers of exported R functions have decreased since then to around 17
exported and 40-45 non-exported functions per package in 2021. Numbers of
functions defined in `/src` directories have followed broadly similar
trajectories to exported `/R` functions, slightly decreasing since the early
2000's to between 30-40 functions. Numbers of functions per source file in both
`/R` and `/src` directories have nevertheless progressively decreased since the
early 2000's to now amount to less than four `/R` functions and just over five
`/src` functions per file (Fig. 4D).

```{r fig04, child = "figures/fig04.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

### Sequential Releases

Figure 5 shows results equivalent to Fig. 4, but for the development of the
respective metrics with each sequential release of a package, rather than being
averaged over all packages for each year. Lines of code generally increase as
packages mature, with mean numbers of lines in the `/R` directory increasing
tenfold from under 400 for first releases to over 5,000 in packages with
100 or more releases. LoC in `/inst` directories also tend to increase as
packages develop, although to a lesser extend, and only becoming notable after
around 50 releases. Beyond the first few releases, there are always fewer LoC
in `/src` directories than in `/R` directories. This contrasts with the annual
aggregate results of Fig. 4A, which suggest more LoC in `/src` than `/R`
directories until around 2007, and roughly equal numbers since then. This
difference reflects the fact that most packages have only one or two releases
(the distribution of numbers of releases is not shown here, but manifests a
very smooth exponential decrease), so Fig. 4A is dominated by packages in a
very early state of development, for which LoC in `/src` often exceed numbers
in `/R`. The decrease in the later phases of package maturation, beyond around
50 releases, may reflect restructuring code from the `/src` to the `/inst`
directories, in order to allow cross-compilation by other packages. This clear
peak in LoC in `/src` directories may suggest this is an approximate number of
releases before other developers become aware of the functionality of package
`/src` directories. The clearest result of Fig. 4A is manifest in total LoC,
which increases in a strikingly linear manner even out to the 100th release of
a package.

```{r fig05, child = "figures/fig05.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

These increases in LoC nevertheless corresponded to general decreases in
LoC per function with increasing numbers of releases (Fig. 5B). Similar to the
aggregate LoC measures of panel A, `/src` directories represent the only
location where LoC manifest a distinct peak as packages matured, with LoC per
`/src` function peaking slightly earlier (after around 40 releases) than total
LoC (slightly over 50). In all directories, LoC per function either slightly
increased or remained generally stable over the first 50 or so releases, beyond
which functions in all directories clearly become considerably more
streamlined, and LoC decreases markedly out to the 100th release. These
decreases are nevertheless relatively minor, and amount to removing one LoC per
function for every 5, 7, or 18 releases for exported R, non-exported R, or
source functions, respectively.

The increasing total measures of LoC of panel A combined with decreasing LoC
per function of panel B must mean that more functions are added as packages
mature, which is precisely what Fig. 5C reveals. Packages initially contain
around less than ten exported functions on average, yet this increases over 10-fold
to over 130 by the 100th release. Numbers of `/src` functions are initially
higher, at around 20, and increase relatively less, to around 100 after 100
releases. Numbers of non-exported `/R` functions manifest the most pronounced
increase, of over 15 times from 20 functions for initial releases, to well over
300 for the 100th release. Finally, numbers of functions per file show no clear trend
for `src` code, remaining broadly stable at around six functions per file (Fig.
4D). In contrast, `/R` code files begin with 3-4 functions per file, and
increase progressively to around eight functions per file after 100 releases,
in the context of Figs. 4B-C clearly mostly due to breaking large non-exported
functions down into multiple, smaller functions.

Finally, the numbers of functions depicted in Fig. 4C actually counts any
arbitrary code objects in all languages contained in `/src` directories, and so
corresponds directly to the "modules" posited to increase according to the
inverse-square "law" of software evolution
[@Turski96;@software-evolution-97;@Turski02]. The defining qualitative feature
of such inverse--square growth is an initially highly concave form, with rates
decreasing notably as packages mature. The trajectories of Fig. 4C appear in
contrast strikingly linear, all manifesting trajectories which would be very
poorly described by such an inverse-square form.

```{r turski, echo = FALSE, eval = FALSE}
datafile <- file.path (here, "data-raw", "pkgstats-results.Rds")
x <- load_pkgstats_data (datafile, raw = TRUE, latest = FALSE) |>
        group_by (package) |>
        mutate (seq = seq_along (package))
x$loc_R [which (is.na (x$loc_R))] <- 0L
x$loc_src [which (is.na (x$loc_src))] <- 0L
x$loc_inst [which (is.na (x$loc_inst))] <- 0L
x$loc_total <- x$loc_R + x$loc_src + x$loc_inst

x_rel <- x |>
    group_by (seq) |>
    filter (seq <= 100) |>
    summarise (
        n = logmean (n_fns_r_exported + n_fns_r_not_exported + n_fns_src, na.rm = TRUE))

s_inv <- cumsum (1 / x_rel$n ^ 2)
E <- mean ((x_rel$n - x_rel$n [1]) / s_inv)
fit <- rep (x_rel$n [1], nrow (x_rel))
for (i in seq (nrow (x_rel)) [-1]) {
    fit [i] <- fit [i - 1] + E / (fit [i - 1] ^ 2)
}
x_rel$fit <- fit
x_rel <- pivot_longer (x_rel, c (n, fit))

ggplot (x_rel, aes (x = seq, y = value, colour = name)) +
    geom_line ()
    #geom_smooth (method = "loess", formula = "y ~ x")
```


## Package Imports and Exports

Like the "standard" libraries for the python language, R has a core set of
"base" and "recommended" packages. The function call networks extracted by
`pkgstats` enable counting numbers of calls to each of these groups of
packages, as well as to "contributed" packages hosted on CRAN.

### Annual Developments

Figure 6A shows the change over time in proportions of calls to these three
groups of packages, revealing a recent tendency (since around 2015) of fewer
calls to base R functions, from over 80% of all function calls in the early
2000s, to below 70% in the previous two years. This decrease has been offset by
greater numbers of calls to functions in contributed packages, while calls to
recommended packages have remained generally stable at around 20%. Although
calls to contributed packages have always represented the lowest proportion of
these three groups, this recent increase nevertheless places them on almost
equal proportion (at 12%) to calls to recommended packages (at 18%).

```{r fig06, child = "figures/fig06.Rmd", eval = TRUE, echo = FALSE}
```

Figure 6B shows the "coupling instability" of packages over time. As explained
above, this is a measure of the extent to which packages depend on external
functionality (efferent couplings) without other packages in turn depending on
them (afferent couplings). Packages on CRAN were largely stable until around
2010, at a coupling instability of around 0.5, meaning numbers of functions
from each package which were imported by other packages were roughly equal to
numbers of external functions each package imported. Instability has increased
markedly since that time, indicating that packages have become increasingly
dependent on external functionality, while the average package is less likely
to provide functionality used by other packages. The coupling instability over
the preceding two years of around 80% implies that packages make on average
eight calls to other packages for every two calls made to that package.

Figure 6C depicts changes in numbers of unique function calls from each package
to the top ten contributed packages, defined as the ten packages with the
largest total number of unique function calls from all packages throughout the
history of CRAN. The top two packages of {ggplot2} and {dplyr} account for
`r prop_top2`% of all function calls from all contributed packages over the
time shown. Numbers of function calls are shown on a logarithmic scale, with
numbers of calls to each of these packages increasing exponentially between
2013 and 2018, before levelling off or even slightly decreasing.

### Sequential Releases

The first two panels of Figure 7 show results equivalent to Figs 6A-B, but for changes with
progressive releases of each package. Proportions of calls to the three
categories of packages (Fig. 6A) stay very similar across releases, and so Fig.
7A shows a slightly modified form quantifying proportional changes between
successive releases. This reveals that values for both base and recommended
packages remain above one out to around 30-40 releases, indicating that
packages progressively decrease calls to contributed packages in favour of
calls to base and recommended packages over the initial development phases.
(Equivalent proportions of calls to recommended packages stay broadly constant,
albeit with marked variability, and are not shown.) Beyond around 20-30
releases, relative rates of change approach the stable level of 1, and
proportions to these three categories of packages remain relatively stable.


```{r fig07, child = "figures/fig07.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Figure 7B shows the average trajectory of coupling instability for individual
packages across the depicted numbers of sequential releases, which decreases
very progressively as packages mature, as should be expected if packages are
increasingly likely to be imported by other packages (that is, afferent
coupling should generally increase). That figure also shows average numbers of
efferent couplings, or numbers of outward calls from each package to other
packages, which stay largely stable as packages develop. Increases in package
stability thus arise as packages develop purely through being imported as
dependencies by increasing numbers of other packages. This in turn suggests
that the best way to counteract the increasing coupling instability of CRAN as
a whole depicted in Fig. 6B would be to ensure that packages remain
progressively developed, rather than abandoned after only a few releases.

Finally, Fig. 7C shows progressions of both packages and individual functions
being imported into other packages as a function of release sequence. The
number of packages importing a package increases progressively with numbers of
releases, as was already clear from Fig. 7B. Packages with less than ten
releases are, on average, imported by very few other packages, while packages
with 40 or more releases are imported by ten other packages on average. The
second line on that figure nevertheless reveals that packages import on average
only 1-2 functions from other packages, and that numbers of functions imported
by other packages increase only marginally as packages mature.

Coupled with the observed increases in numbers of exported functions as
packages mature depicted in Fig. 5C, the slight increase in numbers of
functions imported by other packages nevertheless suggests a relationship
between total numbers of functions exported by a package, and numbers imported
by other packages. Indeed, taking only the latest versions of all packages and
relating these two values reveals that other packages are likely to import one
additional function on average for every 2.8 additional functions exported by
that package.

## Network Analyses

### Annual Developments

The first two panels of Fig. 8 show the temporal development of the CRAN
package dependency network, in both cases revealing that most network metrics
have broadly stabilised over the preceding five or so years, and that
variations were much more pronounced prior to around 2015. The proportion of
terminal vertices, or packages not imported by any other packages, has remained
broadly stable at around 55-60% of all packages. The mean vertex degree of the
dependency network has nevertheless progressively increased, especially since
2015, indicating that those packages which are imported by others have been
imported by increasing numbers of other packages.

```{r fig08, child = "figures/fig08.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Such an increase in average numbers of imports must increase the overall
connectivity of the dependency network, with Fig. 8B showing concomitant
decreases in both centrality metrics over time. Average distances between each
pair of packages in the network increased notably up to around 2013, after
which time they have progressively decreased. Since numbers of terminal
vertices have remained generally stable, while centrality has decreased, the
initial increase in mean distance likely reflects terminal vertices becoming
nevertheless further away, for example through the network evolving a number of
distinct centres. The more recent decrease in mean distance may then reflect an
equivalent centralisation of the dependency network.

The lower two panels of Fig. 8 depict the evolution of function call networks
within individual packages. Fig. 8A shows the ratio of numbers of edges to
numbers of vertices, with higher values indicating more densely connected
networks. Since around 2005, network connections within R functions, whether
exported or not, have remained largely constant, with each function being
called by around 5-6 other functions. Connections between functions in `/src`
directories have in contrast decreased considerably, with each `/src` function
(or object) now being "called" (or referenced, inherited, or any other method)
by just over one other function. Ratios of edges to vertices in the full
function call network extending between all directories (including `/inst`) has
progressively declined from over 4 calls per function to less than 3 in recent
years. Function call networks form on average around three distinct clusters
for each package, peaking at over 3.5 in 2007 before more recently decreasing
to just over 2.5 clusters.

The final panel (Fig. 8D) shows average centrality metrics from function call
networks, revealed a marked stability, except for numbers of terminal edges (in
that context, meaning numbers of functions which call no other functions),
which have decreased since around 2005 from around 12 per package to around 7.


### Sequential Releases

```{r fig09, child = "figures/fig09.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

## Code formatting


```{r fig10, child = "figures/fig10.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

# References
