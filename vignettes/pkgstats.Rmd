---
title: "Historical Trends in R Package Structure and Interdependency on CRAN"
author: "Mark Padgham & Noam Ross"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        number_sections: true
        theme: flatly
bibliography: pkgstats.bib
header-includes: 
    - \usepackage{tikz}
    - \usetikzlibrary{arrows}
vignette: >
  %\VignetteIndexEntry{pkgstats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r pkg-load, echo = FALSE, message = FALSE}
library (pkgstatsAnalyses)
library (ggplot2)
library (patchwork)
library (dplyr)
library (tidyr)
library (igraph)
here <- here::here ()
v_data_dir <- file.path (here, "vignettes", "data")
if (!dir.exists (v_data_dir))
    dir.create (v_data_dir, recursive = TRUE)
logmean <- function (x, ...) {
    10 ^ mean (log10 (x [which (x > 0)]), na.rm = TRUE)
}
```

```{r dl-data, echo = FALSE}
path <- file.path (here, "data-raw")
if (!dir.exists (path)) {
    dir.create (path, recursive = TRUE)
}

u <- paste0 ("https://github.com/mpadge/pkgstats-analyses/",
             "releases/download/v0.0.1/")

f_r <- file.path (path, "pkgstats-results.Rds")
if (!file.exists (f_r)) {
    u_r <- paste0 (u, "pkgstats-results.Rds")
    download.file (u_r, f_r)
}

f_p <- file.path (path, "pypi.Rds")
if (!file.exists (f_p)) {
    u_p <- paste0 (u, "pypi.Rds")
    download.file (u_p, f_p)
}
```


# Introduction

A key component of the success of Open Source Software (OSS) is package
managers [@pkg-mngrs-2018], which effectively serve as curated repositories of
independently-contributed software. Package managers exist both for specific
operating systems [@pkg-mngrs-2018] and specific computer languages such as
python [@new-pypi-2018], LaTeX [@ctan-wiki], JavaScript [@npm-2020], and many
others. This work analyses all current and historically archived packages in
the CRAN (Comprehensive R Archive Network) package manager for the R language.

The majority of prior work on the temporal development or evolution of software
has been based on individual pieces of software, here generically referred to
as "packages". One notably exception is a recent analysis of the "pypi" (Python
Package Index) package manager for python [@pypi2019], which analysed and
presented a number of statistics relevant to the present work, including:

- Compound annual growth rates in numbers of new packages were slightly less
  (at 43%) than growth in active packages (47%) and in new releases (51%).
- Compound annual growth rates in numbers of new package authors was lower than
  these, at 39%.
- Each package has around 7 +/- 19 new releases per year, at an average
  inter-release frequency of 65 +/ 144 days.
- Each author has 2 +/- 17 packages, and 15 +/ 125 releases.
- Median package sizes are 20-40 KB, while mean values are 2-20 MB.
- Total numbers of imported packages increases with compound annual growth rate
  of 62%.
- The standard python libraries represent around 19% of all package imports.

This analyses represents the most comprehensive analysis to date of a package
manager for any computer language, drawn almost two million releases of 179,000
packages. The size of pypi necessarily restricted these analyses to package
metadata, although single metrics of package size were also included. Moreover,
the size of pypi meant that analyses of dependency networks were also
relatively restricted to aggregate statistics only, with no analyses of the
internal properties of dependency networks.

More detailed considerations of temporal development and evolution of code have
largely been restricted to individual packages. Analyses of code evolution
frequently refer to work of @software-evolution-97, who expressed their
findings as a series of "laws" of software evolution. These "laws" include
that, over time, software increases both in complexity and in functional
content (or numbers of functions). Those laws of growth themselves derive from
@Turski96, who posited an inverse-square law for software growth, later
formalised in @Turski02.

This inverse-square "law" was nevertheless an empirical fitting exercise only,
and merely posits the arguably simplest form for a process in which the rate of
growth of a system decreases as the system grows. There is no theoretical
reasons why software evolution should follow such a trajectory, nor do there
appear to have been either any examinations of alternative models of growth, or
of plausible theoretical foundations for any particular model.

These "laws" of software evolution have nevertheless been frequently used and
cited (see overview in @Mens2008, and references therein), although
overwhelmingly for considerations of individual software packages. They have
been widely adopted in a burgeoning field of what might be referred to as
"Software Mining and Analytics", to elucidate useful predictors of software
quality. A useful overview of the field was provided by @mining-repos-2013, who
usefully identified a number of categories, including that of "code statistics"
examined here.

More detailed considerations of package dependency networks have been developed
in more restricted, and thus more manageable, contexts, such as the analysis of
the Debian network of @macro-evolution-2009, which revealed progressive
increases in package inter-dependencies. Although they observe increases in the
sizes of packages over time, and claim that this reflects the laws of
@software-evolution-97, they neither quantify nor model actual rates of change.  <!-- do we or do we plan to? -->
They also observe that the relative sizes of packages, measured in terms of
lines of code, remains relatively stable across releases.

A more extensive consideration of dependency networks alone was provided by 
@seven-pkg-networks-2019, who examined networks from seven package management
systems, including pypi and CRAN. They observe
that both numbers of packages and numbers of dependencies increase more slowly
for CRAN packages than for any of the other systems they consider, as do
numbers of package updates. They also observe that the "survival probability"
(that a package is not updated at some time, $t$) <!-- This seems to be reversed? --> is far greater for CRAN than
for other package ecosystems (although with differences observed between
packages which are not required by other packages, and those which are).
Finally, they observe that the Gini coefficient of inequality between dependent
packages has also increased over time in all systems.

This work focusses on the CRAN package system which is around one tenth the
size of pypi for the python language, although still amounting to over 100,000
releases of around 20,000 packages. This smaller sizes enables far more
detailed analyses than previous work, not just of package metadata, but also
extending to detailed analyses of the code itself.

First, we describe the `{pkgstats}` R package, which can be used to generate
and analyze properties of R package code, and the accompanying database of code
statistics of all historical CRAN packages.  We then describe trends in CRAN
R package properties over the history of the archive (199X-2021).  We focus on
trends in four areas: Package metadata (licenses, authorship, translation),
Package and content (file and function types and sizes), intra-package code
structure (function call networks), and finally, dependency networks amongst
packages. Finally, we discuss implications and likely drivers of these trends,
and potential further applications and extensions of the `pkgstats` package
and database.

# Methods

<!-- This section should be way longer. It shoule
- described pkgstats package in more detail, to the point of basic usage
- describe the different metrics collected - if not a full list, then at least
  categories and a reference to a full list
- describe the usage of `ctags` and generation of relevant network statistics
- describe the availability of the full package database and where to download
  it
-->

Data in this study were generated by the [the R package,
`pkgstats`](https://docs.ropensci.org/pkgstats/), which we developed to
quantify the structure and content of R packages using static code analysis
techniques. That package [includes a function,
`pkgstats_from_archive`](https://docs.ropensci.org/pkgstats/reference/pkgstats_from_archive.html),
which can be applied to a local mirror of the CRAN archive to collate
statistics from all packages. This methodological description begins with an
overview of data sources used, followed by a description of two open-source
libraries for "code tagging" used in the `pkgstats` package. We then describe
the package itself, before providing details of statistical analyses.

## Data: R packages and the CRAN server

Our primary data source comprised every version of every R package hosted on
the "Comprehensive R Archive Network" or CRAN, which is the centralised
distribution system for R packages. The `R` language itself is defined by a
single "package" referred to as "base R". By default, all installations of `R`
also [include a suite of "recommended"
packages](https://github.com/wch/r-source/tree/trunk/src/library). All other
packages are referred to as "Contributed Packages". A number of the following
results distinguish between base, recommended, and contributed code or
packages.

CRAN currently holds close to 19,000 contributed packages, and also maintains a
complete archive of all previous versions of all packages, including of
archived packages no longer available on CRAN. The data analysed here were
generated from a local mirror of the entire CRAN repository, including all
current and archived packages, and amounting to around 105,000 packages (for an
average of slightly over 5 releases per package). The raw data for these
analyses are the contributed packages themselves. While relationships to
objects (functions) in the base and contributed packages are considered, the
structure of the base and recommended packages is not analysed here.

All R packages accord with the structure defined in the ["*Writing R
Extensions*"
Manual](https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages)).
Many aspects of the following analyses were applied to different components of
R packages, in particular the following main sub-directories:

- The `R` directory which holds all source files in the `R` language;
- The `src` directory which holds all code in other languages which needs to be compiled on package installation;
- The `inst` directory which generally holds bundles of external code, but may
  also include code used for cross-linking in compilation, including of other
  packages. Cross-linked code must be in an `inst/include` sub-directory (as
  explained in [this section of the "*Writing R Extensions*"
  Manual](https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages)).
  All of the following analyses only consider the `inst/include` directory, and
  all references to the `inst` directory imply this sub-directory only.
  Analyses excluded all other sub-directories within the `inst` directory.
- The `vignettes` directory which includes extended documentation. (Such
  documentation may also be placed in an `inst/doc` folder, but this was
  ignored here.)
- The `tests` directory containing test files.
- The `data` directory containing data files used to implement or demonstrate
  package functionality.


## Code tagging with "ctags" and "gtags"

The `pkgstats` package is a static code analysis tool specifically developed
for R packages, with much of the functionality extending from two general
static analysis tools. Static code analysis tools generally work by
constructing parse trees which relate a grammar describing one or more computer
languages to each expression encountered by tracing the code. An important
first step is to "tag" each expression, identifying the kind of expression and
its scope (generally its membership either of some component of the underlying
grammar, or some more local scope such as definitions within locally-sourced
files).

The `pkgstats` package uses two open-source libraries for code tagging and
parse tree construction: "ctags" and "gtags". The original "ctags" library is
no longer maintained, and these analyses used a maintained version called
["Universal ctags"](https://ctags.io) which,

> generates an index (or tag) file of language objects found in source files
> for programming languages.

This library was used here to tag each expression in the `R`, `src`, and
`inst/include` directories, providing the following data for each tagged item:

1. The tag itself, such as the name of a function, variable, or other object;
2. The name of the corresponding file;
3. The full content of the expression in which that tag was used (as a text string);
4. The kind of object (in `R` files, generally a `function`, `functionVar` or
   variable defined within a function, `globalVar` for global variables, or
   other objects defined by the `R` language; kinds of objects can be
   arbitrarily diverse in other languages);
5. The computer language in which that object was referenced; and
6. The start and end line numbers of the file in which that object is defined
   or referenced.

The "ctags" data for R files were also used to construct an "external call
network" of references to all R functions in all packages, including the
package being analysed, the base and recommended packages, and all other
contributed packages imported by each package. Functions were attributed to
packages by matching function names. Function names in R do not have to be
unique, and "namespace conflicts" may arise between packages implementing
different functions with the same name. We presumed that namespace conflicts
most commonly arise in re-definitions of functions initially defined in base or
recommended packages, and in all such cases we attributed a function to the
external or contributed package over base or recommended definitions.

The "gtags" library, itself part of the [GNU Global
library](https://www.gnu.org/software/global/), generates entries for every
expression, with the "tag" itself defining the environment for that expression.
This enables mappings to be made between every expression and its corresponding
tag. We used "gtags" to construct object reference networks across all computer
languages used in R packages (such as C, C++, or Python), to enable the
construction of "function call networks" within and between all languages.
While the terms "functions" and "calls" may not be appropriate for all computer
languages and/or classes or types of objects, they nevertheless reflect the
functionality of R code, and so are preferred here, even when referring to
other object relationships such as class inheritance mechanisms.

It is possible to cross-compile "gtags" with "ctags", to enable "gtags" to use
the more expansive language parsing abilities of "ctags", and to greatly extend
the range of languages able to be parsed by "gtags". In particular, "gtags"
does not not by default parse R code, yet does so when cross-compiled with
Universal "ctags". Cross-compiled installations of "gtags" are, however,
generally several times slower than simpler installations, and so these
analyses did not use a cross-compiled version. While this meant restricting
analyses to a smaller subset of potential languages, the output of "ctags"
itself nevertheless describes tags in all possible languages, with "gtags" only
used to map function call networks in languages other than R. Function-call
networks within R were extracted from the "ctags" output as described above,
and one additional function was written to link calls within R code as defined
by the "ctags" output to external objects defined in other languages and
specified by the "gtags" output. This enabled full function-call networks to be
constructed within and between different languages used in R packages. Several
properties of these networks were analysed as described below.

Data generated by "ctags" and "gtags" which were analysed here included:

- Numbers of internal and external functions in R.
- Numbers and kinds of all objects in all other languages.
- Numbers of Lines-of-Code for each function or object definition in each language.
- References from each function (or object) make to all other functions (or
  objects), including references made to all functions defined in other base,
  recommended, or contributed R packages.



## The `pkgstats` package

This sub-section describes additional data generated by `pkgstats` beyond that
extracted from "ctags" and "gtags". The full list of all data generated by the
package is given in [the online
documentation](https://docs.ropensci.org/pkgstats/), with this sub-section only
describing those aspects which were analysed here.

### 'DESCRIPTION' files

All R packages must include a [Debian Control
File](https://www.debian.org/doc/debian-policy/ch-controlfields.html) ("DCF")
called "DESCRIPTION" which contains a subset of standard DCF fields, including
[a number of standardised and mandatory
fields](https://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file)
able to be analysed here. We extracted:

- Numbers of authors (as individuals with a specified role of "aut");
- Numbers of contributors (as individuals with a specified role of "ctb");
- Full entries of the "License" field specifying the type of license under
  which the software was released; and
- Entries in the "URL" field specifying one or more Uniform Resource Locators
  (URLs) for the package.
- Lists of all imported packages used to construct dependency networks between
  packages. (Neither required nor suggested packages were considered here.)

### Translation files

R packages may include [files used to translate all messages issued by code into
other (human)
languages](https://cran.r-project.org/doc/manuals/R-exts.html#Preparing-translations).
These files are placed in a dedicated `/po` sub-directory, with file names
prefixed with standard prefixes (generally, but not necessarily, [ISO 639-1
codes](https://en.wikipedia.org/wiki/ISO_639-1)). This format enables
translations to be readily identified and extracted. `pkgstats` extracts a list
of all translations provided for each package.

### Lines of Code (LoC)

`pkgstats` includes its own internal tool (coded in C++) for analysing
Lines-of-Code (Loc). This tool produces output similar to many common LoC
tools, with additional data on:

1. Total numbers of code, comment, and blank lines;
2. Total numbers of characters in code lines, along with total numbers of
   white-space characters, to enable metrics of proportional white space; and
3. Code indentation, including identification of tab-indentation.

### Function-level analyses

The "ctags" and "gtags" output described above provides data on the start and
end points of each function definition, along with names of associated files.
These data were used to provide estimates of average LoC per function, and
numbers of function definitions per file. (Where, as explained above,
"function" is used here as generic label for any object in any language, such
as class definitions.)

Each exported function in an R package must have a corresponding documentation
file in the `/man` directory of the package with the suffix, `.Rd` for "R
documentation". `pkgstats` also statically parses these files with [the
`parse_Rd` function of the recommended `tools`
package](https://stat.ethz.ch/R-manual/R-devel/library/tools/html/parse_Rd.html).
For the present analyses, this enabled identification of the number of
parameters for each function, and the number of documentation characters for
each parameter. Total length of documentation for each function was also
quantified as the number of lines in the output produced by converting the
result of `parse_Rd` to text (via the `tools::Rd2txt` function).


## Network Analyses

Two distinct kinds of network analysis were performed here: *inter-package*
analyses of dependency networks between packages (akin to
@seven-pkg-networks-2019), and *intra-package* analyses of the function call
networks extracted from the "ctags" and "gtags" data described above.

### Inter-Package Network Analyses

The 'DESCRIPTION' files of R packages must specify all external packages which
a package imports. These data can be used to construct a full dependency
network of all packages. The results below present the following measures
derived from package dependency networks, all of which were calculated with the
`igraph` package [@igraph].

1. Numbers of packages which are not imported by any others - the terminal
   vertices in a dependency network; 
2. Average "in-degree" of network vertices, or average numbers of times each
   package is imported by others;
3. The average *betweenness centrality* of each edge, which is the number of
   times that edge is traversed in connecting every package to every other
   package in the network;
4. The network-level *degree centrality*, which is a measure of vertex degree
   standardised to the overall size and structure of the network
   (@network-centrality-79).
5. A measure of the overall "size" of the network as the average distance
   between all pairs of vertices.

Betweenness centrality provides insight into how centralised the network is,
with higher values reflecting networks in which connections frequently traverse
a common, central region. The network-level degree centrality reflects the
extent to which vertices all have a relatively high in-degree; networks in
which all networks have an equal in-degree have no effective centre, and so
have a degree centrality of zero. In contrast, networks with a few
highly-connected central vertices and many vertices with low in-degree will
have a high degree centrality. These two centrality metrics provide slightly
different insights: betweenness centrality will increase to the extent to which
a network manifests a single, common centre; degree centrality will increase to
the extent that networks become more centralised in general, regardless of
whether or not any singly identifiable centre forms.

Networks with low degree centrality are readily traversable, and so will
generally have lower average distances between all pairs of vertices. The
distance metric nevertheless may offer additional insight, and will for example
be higher independent of degree centrality for networks with extended
peripheral connections. Finally, we note that clusters or local network
communities were not considered here, as the dependency networks of CRAN
packages are almost always so highly connected that the largest connected
cluster represents over 99% of the network.

### Intra-Package Network Analyses

Intra-package networks were constructed from the function call networks
described above, and included overall package networks connecting code in all
sub-directories, as well as network analyses of only those components
representing individual sub-directories, here constrained to network analyses
of both `/R` and `/src` code. Function call networks within individual packages
are commonly structured in several distinct clusters, and thus numbers of
clusters provided an important first metric for intra-package analyses.
Intra-package analyses considered the following metrics:

1. Ratio of numbers of edges to numbers of vertices.
2. Numbers of distinct clusters between all functions or objects across all
   languages.
3. The betweenness centrality of the function call network.
4. Numbers of terminal vertices (functions which do not call any other
   functions).
5. The average vertex degree.


## Coupling Instability

[Coupling Instability](https://en.wikipedia.org/wiki/Software_package_metrics)
is an important concept in the analysis of software dependency networks
[@martin-agile-2002], and depends in turn on numbers of so-called *afferent*
and *efferent* couplings. For any given packages, these are defined as:

- *Afferent Couplings* as numbers of functions in other packages which depend
  on functions within the package.
- *Efferent Couplings* as numbers of functions from other packages which the
  package depends on.

*Afferent* couplings are numbers of *inbound* edges from all other packages to
a given package, while *efferent* couplings are *outbound* edges coupling that
package with all other packages. Respectively denoting afferent and efferent
couplings by $n_a$ and $n_e$, the coupling instability, $I$, is then defined
as $I = n_e / (n_e + n_a)$. Packages which depend on many external calls (high
efferent couplings), yet upon which few other packages depend (low afferent
couplings) thus has a high coupling instability, while packages upon which many
other packages depend, yet which themselves depend on few other packages have a
low coupling instability. The analyses below quantified coupling instability
for each package from the dependency networks, using total numbers of function
calls between all packages, in order to estimate the average coupling
instability of the entire network.

## Statistical Analyses

The following results depict and interpret qualitative trends and patterns,
without reporting on any statistical tests. In frequentist terms, data were
sufficiently large ($N > 105,000$) to ensure that all of the reported results,
were they to be analyses as linear relationships, were entirely significant.
There are two further important aspects to note in regard to statistical
analyses detailed below.

### Temporal Analyses

Most of the following results depict the evolution of CRAN software over time,
in two main ways:

1. As annual developments averaged over all packages; or
2. As developments for individual packages over sequences of releases.

For continuously updated repositories like CRAN, annual developments can be
captured in the following two primary ways:

1. Through considering each year to represent the state of CRAN at that time,
   and thus to include latests releases of all packages for that year,
   regardless of how long ago a package may previously have been updated.
   Annual estimates derived this way are referred to here as **CRAN
   snapshots**.
2. Through considering each year to represent only the state of CRAN in terms
   of packages uploaded in that specific year, disregarding any packages
   uploaded in prior years. Estimates derived this way are referred to simply
   as **annual** values.

Under the plausible assumption that rates of package updates follow some kind
of Poisson-like process, the ages of packages at any given time will be
exponentially distributed, analogous to distributions of waiting times for
Poisson processes. This means that values derived using **CRAN snapshots** will
generally reflect exponentially-smoothed versions of **annual** values. Many of
the graphical results which follow depict results dervied using both of these
approaches, in which:

- solid lines represent annual values, which are generally noiser versions of
- dashed lines, which represent effectively exponentially-smoothed versions of
  the same data using CRAN snapshots for each year.

Where no additional interpretations are given, solid lines in all of the
results that follow represent annual values, while dashed lines represent
results derived from CRAN shapshots. See Fig. 1A immediately below, for an
example. Where also not otherwise mentioned, all reported values refer to
annual values, and not to values derived from CRAN snapshots.


### Distributional properties and mean values

Almost all statistics described above, and presented in the results below, were
approximately log-normally distributed. References in any of the following
results to mean values thus imply values calculated as `10^mean(log10(x))`. The
use of direct mean values did not generally alter any of the qualitative
conclusions which follow, yet resulted in many cases in less distinct or smooth
trajectories or results.

# Results

## Metadata

The relatively regulated process of CRAN submissions [@seven-pkg-networks-2019]
is reflected in more regulated meta-data able to be extracted from package
'DESCRIPTION' files. Numbers of both authors and contributors have increased
over time (Fig. 1A), with contributors having been rarely acknowledged at all
prior to 2010 (two years after the launch of GitHub), increasing to an average
of one acknowledged contributor per package in 2021.

Numbers of unique licenses primarily reflect numbers of ways of declaring
licenses, rather than actual numbers of licenses. Figure 1B shows a roughly
linear increase in license declarations up to around 2007, followed by a
pronounced drop and progression into a roughly stable range of somewhere over
50 distinct entries. The different ways of specifying the three versions of GPL
licenses have accounted for over 83% of all CRAN packages, with the second most
common type license being MIT, at 9.6%, followed by BSD at 2.0%. One of these
three licenses are used in 95% of all CRAN packages.


```{r fig01, child = "figures/fig01.Rmd", eval = TRUE, echo = FALSE}
```

```{r licenses, echo = FALSE}
datafile <- file.path (here, "data-raw", "pkgstats-results.Rds")
x <- load_pkgstats_data (datafile, raw = TRUE, latest = FALSE)
index <- which (x$year > 2010)
lic <- sort (table (x$license [index]), decreasing = TRUE)
lic <- data.frame (license = names (lic),
                   n = as.integer (lic))
#knitr::kable (lic [1:10, ], caption = "**Table 1.**")

index <- grep ("GPL|general\\spublic\\slic", lic$license)
prop_gpl <- sum (lic$n [index]) / sum (lic$n)
index <- grep ("BSD", lic$license)
prop_bsd <- sum (lic$n [index]) / sum (lic$n)
index <- grep ("MIT", lic$license)
prop_mit <- sum (lic$n [index]) / sum (lic$n)
prop3 <- prop_gpl + prop_bsd + prop_mit
```

The practice of translating messages within R packages into other languages has
steadily declined in recent years (Fig. 2A), suggesting a pronounced increase
in acceptance over the last 15 or so years of English as a globally standard
language, and a concomitant decrease in active acknowledgement of other
languages. (The `en@quot` translation entry is described in the [*R
Installation and Administration*
Manual](https://cran.r-project.org/doc/manuals/R-admin.html#Localization-of-messages)
as a translation which, "can be used in a UTF-8 locale to have American error
messages with pairs of single quotes translated to Unicode directional
quotes.") Rates of decrease since 2008 equate to 1.5% fewer packages per year
including translations, from a total of just over 20% of all packages in 2008,
to barely over 1% in 2021. While rates of decreased have slowed somewhat in
recent years, extrapolation of the preceding five years nevertheless suggests
that the practice of offering translations will entirely disappear by 2023.

```{r fig02, child = "figures/fig02.Rmd", eval = TRUE, echo = FALSE}
```


Finally, analyses of URLs provided in package 'DESCRIPTION' files clearly
reveals an abrupt break after around 2010 with the advent of online code
repositories. GitHub has always dominated, while r-forge has declined
progressively since around 2015. The most notable increase has been the
emergence of rOpenSci as provider of the only URL to come close to within
1/20th of the popularity of GitHub over the past few years.


## Package Structure and Content

### File Structure

The temporal development of numbers of files manifest several notable
characteristics (Figure 3). Unsurprisingly, R packages have always been
dominated by files in the `R/` directory, numbers of which increased considerably
up to around 2010, after which they are generally stabilised at a mean value of
around 20 files (Fig. 3A). The `src` and `data` directories are the only places
within an R package in which numbers of files have remained relatively constant
over the preceding 20+ years. Packages generally had very few files in the
`inst` directory prior to 2010, after which they have notably increased. The
two sub-directories in which numbers of files have increased most significantly
are `vignettes` and `tests`, clearly indicating that packages have become both
better documented and better tested, especially since 2010.


```{r fig03, child = "figures/fig03.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Figure 3B shows equivalent relative changes within individual packages across
successive releases. The changes there are proportional changes in numbers of
files in each of the nominated directories, starting with the change between
the second and first release (a "Release sequence" of 2). Although numbers of
files generally increase with each new release, *rates* of increase tend to
slow down, with packages approaching stability (a ratio of 1) after around 20
releases.  <!-- if this is the case, you should plot the trend out to 20 releases -->

### Function Number, Type and Size

Figure 7 shows the temporal evolution of a number of code metrics. These
figures distinguish between the two primary kinds of R functions, exported and
non-exported, and also between the main sub-directories of R packages:

- The `R` directory holding all source files in the `R` language;
- The `src` directory holding all code in other languages which needs to be compiled on package installation;
- The `inst` directory generally holding bundles of external code, but also
  including code linked to within `src` code and used for cross-linking in
  compilation of other packages.

Lines of Code ("LoC") in the primary `R` and `src` directories broadly
increased up to around 2010 or slightly later, after which time LoC in these
directories has progressively decreased. These follow similar trends in LoC per
function (Fig. 7B), excepting the early years of CRAN, during which functions
often had well over 100 lines each, especially `src` functions defined in other
languages.

Total numbers of R functions initially increased until around 2007, peaking at
just under 50 exported and 75-80 non-exported functions per package (Fig. 7C).
Numbers of exported R functions have decreased since then to around 27
functions per package in 2021. In contrast, numbers of functions defined in
`src` directories have progressively increased, and now total just over 150
functions. In both `R` and `src` directories, numbers of functions per source
file have nevertheless progressively decreased since the early 2000's to now
amount to less than six `R` functions and just over 8 `src` functions per file
(Fig. 7D).



@static-analysis-2016,

## Intra-package function call networks


## Dependency Networks

Like the "standard" libraries for the python language, R has a core set of
"base" and "recommended" packages. Figure 4A shows the change in the relative
use of these compared with "contributed", or externally user-generated
packages, over time. The use of recommended packages has remained relatively
constant over time, representing around 15-20% of all function calls. Calls to
base R functions represented over 80% of all function calls in the early 2000s,
yet have declined in recent years to below 70% (for unique function calls).
This reduction has been offset by a concomitantly pronounced increase in calls
to functions from contributed packages.


```{r fig04, child = "figures/fig04.Rmd", eval = TRUE, echo = FALSE}
```

Figure 4B shows the "coupling instability" of packages over time. This is the
proportion of *afferent* to total couplings, where afferent couplings are
numbers of (unique) calls that a package makes to dependent functions defined
in other packages. Total couplings include *efferent* couplings, or calls from
other packages to functions of a given package. This measure of instability is
thus a measure of the relative dependence of a package on external
functionality compared with the observe dependence of other packages on that
package. Packages which depend on many external functions, yet on which no
other package depends are thus "unstable", whereas packages with little or not
dependence on external packages, yet upon which many other packages depend, are
comparably "stable".

This result reveals that instability remained broadly stable until around 2012,
after which it has progressively increased, from around 50% to almost 80%. This
latter figure means that packages make on average eight calls to other packages
for every two calls made to that package.

Figure 4C depicts changes in numbers of unique function calls from each package
to the top ten contributed packages, defined as the ten packages with the
largest total number of unique function calls from all packages throughout the
history of CRAN. Numbers of function calls are shown on a logarithmic scale,
with numbers of calls to each of these packages increasing exponentially since
around 2013. The top two packages of {ggplot2} and {dplyr} account for
`r prop_top2`% of all function calls from all contributed packages over the
time shown.

Figure 5 shows results equivalent to Figs 4A-B, but for changes with
progressive releases of each package. The first panel (Fig. 5A) shows changes
in the proportion of calls to the base and recommended packages for each
sequential release, averaged over all packages. (Equivalent proportions of
calls to recommended packages stay broadly constant, albeit with marked
variability, and are not shown.) Relative changes generally remain above 1,
indicating that packages make progressively more calls to base and recommended
packages as they mature, with rates of calls to recommended packages
progressively decreasing, and approaching stability after around 30 releases.

Calls to the base R package initially increase with each release out to around
10-15 releases, indicating that packages incorporate progressively more calls
to base R functions with each release. Beyond around 15 releases, relative
rates of change also approach the stable level of 1, as for calls to
recommended packages, with no further calls being added.

Figure 5B shows the average trajectory of coupling instability for individual
packages across the depicted numbers of sequential releases. While decreases in
coupling instability should be expected as packages mature and are imported by
increasing numbers of other packages (that is, afferent coupling should
generally increase), that figure also shows that mean numbers of efferent calls
tend to decrease with each sequential release. Numbers of afferent calls (that
is, inward calls from other packages to a given package) also naturally
increase with sequential releases, as increasing numbers of packages depend on
a given package. The observed decrease in instability reflects this combination
both of increasing dependence of other packages on any given package, and
decreasing dependence of packages on functionality provided by external
packages.

Finally, Fig. 5C shows progressions of packages being imported into other
packages as a function of release sequence. The number of packages importing
a package increases progressively with numbers of releases. Packages with less
than ten releases are, on average, imported by very few other packages, while
packages with 30 or more releases are imported by ten other packages on
average. The second line on that figure nevertheless reveals that numbers of
functions actually used by other packages increase above one after around ten
releases, yet always remain below two on average, even for packages with 50 or
more releases.

```{r fig05, child = "figures/fig05.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

## Temporal Development #3: Code Metrics

Figure 6 shows the temporal evolution of a number of code metrics. These figures distinguish between the two primary kinds of R functions, exported and non-exported, and also between the main sub-directories of R packages:

- The `R` directory holding all source files in the `R` language;
- The `src` directory holding all code in other languages which needs to be compiled on package installation;
- The `inst` directory generally holding bundles of external code, but also
  including code linked to within `src` code and used for cross-linking in
  compilation of other packages.

### Annual Developments

Lines of Code ("LoC") in the primary `R` and `src` directories broadly
increased up to around 2010 or slightly later, after which time LoC in these
directories has progressively decreased. These follow similar trends in LoC per
function (Fig. 6B), excepting the early years of CRAN, during which functions
often had well over 100 lines each, especially `src` functions defined in other
languages.

Total numbers of R functions initially increased until around 2007, peaking at
just under 50 exported and 75-80 non-exported functions per package (Fig. 6C).
Numbers of exported R functions have decreased since then to around 27
functions per package in 2021. In contrast, numbers of functions defined in
`src` directories have progressively increased, and now total just over 150
functions. In both `R` and `src` directories, numbers of functions per source
file have nevertheless progressively decreased since the early 2000's to now
amount to less than six `R` functions and just over 8 `src` functions per file
(Fig. 6D).

```{r fig06, child = "figures/fig06.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

## Intra-package Developments

Figure 7 shows results equivalent to Fig. 6, but for the development of the
respective metrics with each sequential release of a package, rather than being
averaged over all packages for each year. Lines of code generally increase as
packages mature, with mean numbers of lines in the `R` directory increasing
tenfold from under 1000 for first releases to almost 10,000 in packages with
100 or more releases. Changes in LoC in `src` and `inst` directories were less
clear, yet the dominance of `R` code nevertheless produced an overall increase
in LoC out to the 100th release of packages of around 12 times.

These increases in LoC nevertheless corresponded to an equivalent decrease in
LoC per function with increasing numbers of releases (Fig. 7B). Similar to the
aggregate LoC measures of panel A, LoC per function in `src` directories
remained broadly stable over releases, while LoC per `R` function decreased
notably, and more so for exported than non-exported functions. Exported
functions after 100 releases had just over 30 LoC per function, whereas initial
releases average just under 60 LoC.

The increasing total measures of LoC of panel A combined with decreasing LoC
per function of panel B must mean that more functions are added as packages
mature, which is precisely what Fig. 7C reveals. Packages initially contain
around 20 exported functions on average, yet this increases almost 13-fold to
over 250 by the 100th release. Non-exported functions increase by a similar
10-fold proportion over the first 100 releases, while packages start with more
many more `src` functions on initial releases, and so increases relatively less
as packages mature. Finally, numbers of functions per file show no clear trend
for `src` code, while approximately doubling in `R` code over the first 100
releases of a package, from around 7 to 15.

```{r fig07, child = "figures/fig07.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

The inverse-square "law" of software evolution merely posits that rates of
development increase as software matures. Development is quantified in terms of
numbers of abstract "modules", which in R code could be interpreted as
functions. The models of @Turski96 and @Turski02 describe how numbers of
functions increase between each release.

```{r turski, echo = FALSE, eval = FALSE}
datafile <- file.path (here, "data-raw", "pkgstats-results.Rds")
x <- load_pkgstats_data (datafile, raw = TRUE, latest = FALSE) |>
        group_by (package) |>
        mutate (seq = seq_along (package))
x$loc_R [which (is.na (x$loc_R))] <- 0L
x$loc_src [which (is.na (x$loc_src))] <- 0L
x$loc_inst [which (is.na (x$loc_inst))] <- 0L
x$loc_total <- x$loc_R + x$loc_src + x$loc_inst

x_rel <- x |>
    group_by (seq) |>
    filter (seq <= 100) |>
    summarise (
        n = mean (n_fns_r_exported + n_fns_r_not_exported, na.rm = TRUE))

s_inv <- cumsum (1 / x_rel$n ^ 2)
E <- mean ((x_rel$n - x_rel$n [1]) / s_inv)
fit <- rep (x_rel$n [1], nrow (x_rel))
for (i in seq (nrow (x_rel)) [-1]) {
    fit [i] <- fit [i - 1] + E / (fit [i - 1] ^ 2)
}
x_rel$fit <- fit
x_rel <- pivot_longer (x_rel, c (n, fit))

ggplot (x_rel, aes (x = seq, y = value, colour = name)) +
    geom_line ()
    #geom_smooth (method = "loess", formula = "y ~ x")
```



## Network metrics

```{r fig08, child = "figures/fig08.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

```{r fig09, child = "figures/fig09.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

## Code formatting


```{r fig10, child = "figures/fig10.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

# References
