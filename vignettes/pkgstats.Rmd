---
title: "Historical Trends in R Package Structure and Interdependency on CRAN"
author: "Mark Padgham & Noam Ross"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        number_sections: true
        theme: flatly
bibliography: pkgstats.bib
header-includes: 
    - \usepackage{tikz}
    - \usetikzlibrary{arrows}
vignette: >
  %\VignetteIndexEntry{pkgstats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r pkg-load, echo = FALSE, message = FALSE}
library (pkgstatsAnalyses)
library (ggplot2)
library (patchwork)
library (dplyr)
library (tidyr)
library (igraph)
here <- here::here ()
v_data_dir <- file.path (here, "vignettes", "data")
if (!dir.exists (v_data_dir))
    dir.create (v_data_dir, recursive = TRUE)
logmean <- function (x, ...) {
    10 ^ mean (log10 (x [which (x > 0)]), na.rm = TRUE)
}
```

```{r dl-data, echo = FALSE}
path <- file.path (here, "data-raw")
if (!dir.exists (path)) {
    dir.create (path, recursive = TRUE)
}

u <- paste0 ("https://github.com/mpadge/pkgstats-analyses/",
             "releases/download/v0.0.1/")

f_r <- file.path (path, "pkgstats-results.Rds")
if (!file.exists (f_r)) {
    u_r <- paste0 (u, "pkgstats-results.Rds")
    download.file (u_r, f_r)
}

f_p <- file.path (path, "pypi.Rds")
if (!file.exists (f_p)) {
    u_p <- paste0 (u, "pypi.Rds")
    download.file (u_p, f_p)
}
```


## Introduction

The temporal development of software has been studied for many decades,
commonly through the development of individual pieces of software or, in rarer
cases, comparative studies between a select few pieces of software [see
comprehensive literature reviews in @syeed_evolution_2013;@oss-evolution-2016].
Open source software in many languages is nevertheless increasingly dependent
upon and therefore shaped by developments in other packages or libraries. Any
computer language has associated with it an evolving ecosystem of software, and
the evolution of any one component of that ecosystem is best studied in the
context of the evolution of the ecosystem as a whole. In short, the development
or evolution of open source software is better studied in *collective* rather
than *individual* terms. 

One focal point of historically individual studies on software evolution has
been the work of @software-evolution-97, who expressed their findings as a
series of "laws" of software evolution. These "laws" include that, over time,
software increases both in complexity and in functional content (or numbers of
"modules"). Those laws of growth themselves derive from @Turski96, who posited
an inverse-square law for software growth, later formalised in @Turski02,
albeit as a purely empirical exercise absent any firm theoretical reasoning.

These "laws" of software evolution have nevertheless been frequently used and
cited [see overview in @Mens2008, and references therein], and have strongly
influenced the development of a research field which might be referred to as
"Software Mining and Analytics", which has itself particularly focussed on
elucidating useful predictors of software quality. A useful overview of the
field was provided by @mining-repos-2013, who empirically identified a number
of research categories within this broad field, including one of "code
statistics" which describes this present research.

For many computer languages, individual pieces of open-source software --
hereafter referred to as "packages" -- are held and distributed through
centralised package distribution services [@pkg-mngrs-2018], which manifest
forms of collective "evolution" above and beyond the evolution of individual
packages. Package distribution services serve as curated repositories of
independently-contributed software, and exist for computer languages including
python [@new-pypi-2018], LaTeX [@ctan-wiki], JavaScript [@npm-2020], and many
others [as well as operating-system specific package distribution services such
as described in @dpkg]. Package distribution services have been analysed and
compared both in terms of static collective properties [for example,
@decan_topology_2016], as well as their temporal evolution, a notable example
of which is @seven-pkg-networks-2019, who examined the evolution of dependency
networks from seven package distribution systems, including the "Comprehensive
R Archive Network", or CRAN, the focus of the present study.
@seven-pkg-networks-2019 observed that both numbers of packages and numbers of
dependencies have increased more slowly for CRAN than for any of the other
systems they considered, as have numbers of package updates. They also observed
that the "survival probability" (that a package is updated after some given
time) has been far greater for CRAN than for other package ecosystems, albeit
with differences observed between packages which are not required or imported
by other packages, and those which are. Finally, they observed that the Gini
coefficient of inequality between dependent packages has also increased over
time in all systems. The total size of the systems studied by both
@decan_topology_2016 and @seven-pkg-networks-2019 nevertheless left relatively
little scope for detailed examinations of the properties of the packages
themselves, leaving analyses more focussed on aggregate properties such as
those of dependency networks.

There have also been detailed considerations of dependency networks from
individual package distribution systems, such as the analyses of the Debian
network by @macro-evolution-2009, who revealed progressive increases in package
inter-dependencies. Although they observed increases in the sizes of packages
over time, and claimed that these reflected the laws of @software-evolution-97,
they neither quantified nor modelled actual rates of change. They also observed
that the relative sizes of packages, measured in terms of lines of code,
remained relatively stable across releases. A recent analysis of the "pypi"
(Python Package Index) package distribution system for python [@pypi2019]
represented the most comprehensive analysis to that time of a single package
distribution system for any computer language, drawn from almost two million
releases of 179,000 packages. The size of pypi necessarily restricted analyses
to package metadata, although single metrics of package size were also
included. Moreover, the size of pypi meant that analyses of dependency networks
were also restricted to aggregate statistics only, with no analyses of the
internal properties of dependency networks themselves. Thus while this
represents an exemplary study of the evolution of a package distribution
system, the size of this system precluded any analyses of how individual pieces
of software evolve both internally, and in relation to the aggregate evolution
of the system as a whole.

The primary aim of the present work is to examine the mutual evolutionary
dynamics of both the collective properties of one package distribution system
and the properties of individual software packages within that system. Detailed
examination of the co-evolution of an entire software system along with
evolutionary trajectories of individual components requires both a package
distribution system of relatively modest size, and one which retains full
archives of all previous packages. One package distribution system which
fulfils both of these criteria is CRAN, or the Comprehensive R Archive Network,
which is around one tenth the size of pypi, although still amounting to over
100,000 releases of around 20,000 packages. CRAN is by far the dominant package
distribution system for R; while other systems such as BioConductor and R-Forge
have been considered elsewhere [@decan_development_2015], the present work
focusses exclusively on CRAN.

This work builds on several prior analysis of CRAN packages. Perhaps most
notably, this present article has been prepared ten years after
@hornik_too_many_R_pkgs_2012 first published his article commemorating his
"early history of the R project" ten years prior to that. In his 2012 article,
Kurt Hornik, one of the instigators of CRAN, calls for,

> a considerable and concerted community effort ... providing R packages to
> compute on R packages.

While he was referring in that context specifically to textual analyses of
documentation files, his perceived absence of resources to "compute on
packages" arguably remains largely true ten years later. Most analyses of the
CRAN software system have considered what might be referred to as "metadata",
such as personal networks of package authors [@plakidas_evolution_2017], or
relationships between CRAN and software development platforms such as GitHub
[@decan_development_2015;@decan_when_2016]. Analyses which have considered
individual packages have also mostly examined simplified aggregate data such as
sizes of packages [@german_evolution_2013], or dependency networks between
packages [@mora-cantallops_complex_2020]. The present work aims to extend
beyond such analyses, by reporting on a tool able to derive detailed data on
the internal structure of every package which has ever existed on CRAN, and to
relate such detailed package-internal data to the extrinsic evolution of the
system as a whole.

We begin by describing the [the `{pkgstats}` R
package](https://docs.ropensci.org/pkgstats), which can be used to generate and
analyse properties of R package code, and the accompanying database of code
statistics of all historical CRAN packages.  We then describe trends in CRAN 
package properties over the history of the archive (1998-2021), focussing on
trends in four areas: Package metadata (licenses, authorship, translation),
internal content and structure (file and function types and sizes),
intra-package code structure (function call networks), and finally, dependency
networks amongst packages. Finally, we discuss implications and likely drivers
of these trends, and potential further applications and extensions of [the
`{pkgstats}` package](https://docs.ropensci.org/pkgstats) and database.

## Methods

We developed [`{pkgstats}`](https://docs.ropensci.org/pkgstats) to quantify the
structure and content of R packages using static code analysis techniques
[@static-analysis-2016]. That package [includes a function,
`pkgstats_from_archive`](https://docs.ropensci.org/pkgstats/reference/pkgstats_from_archive.html),
which can be applied to a local mirror of the CRAN archive to collate
statistics from all packages. The resultant data have been published with the
[v0.0.3 release of the {pkgstats}
package](https://github.com/ropensci-review-tools/pkgstats/releases/tag/v0.0.3).
All results that follow used the `pkgstats-CRAN-all` data, which contain one
row for each package ever published on CRAN (total of 105,375 rows), and 91
column-wise variables quantifying and qualifying many aspects of each package,
as described in the following sub-sections.

This methodological description begins with an overview of the structure of
the CRAN archive and how data were extracted, followed by a description of the
two open-source libraries for "code tagging" used in the
[`{pkgstats}`](https://docs.ropensci.org/pkgstats) package. We then describe
the results generated by the package itself, before providing details of
statistical analyses used to derive these results.

### Data: R packages and the CRAN server

Our primary data source comprised every version of every R package hosted on
the ["Comprehensive R Archive Network" or CRAN](https://cran.r-project.org),
which is the centralised distribution system for R packages. The `R` language
itself is defined by a single "package" referred to as "base R". By default,
all installations of `R` also [include a suite of "recommended"
packages](https://github.com/wch/r-source/tree/trunk/src/library). All packages
other than these are referred to as "Contributed Packages". A number of the
following results distinguish between these three categories of base,
recommended, and contributed packages [@german_evolution_2013].

CRAN currently holds close to 19,000 contributed packages, and also maintains a
complete archive of all previous versions of all packages, including of
archived packages no longer available on CRAN. The data analysed here were
generated from a local mirror of the entire CRAN repository, including all
current and archived versions of all packages, and amounting to around 105,000
individual versions (for an average of slightly over 5 releases per package).
The raw data for these analyses are the contributed packages themselves. While
relationships to objects (functions) in the base and contributed packages are
considered, the structures of the base and recommended packages are not
analysed here.

All R packages must accord with the structure defined in the ["*Writing R
Extensions*"
Manual](https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages)
[as discussed in @hornik_too_many_R_pkgs_2012]. Many aspects of the following
analyses were applied to different components of R packages, in particular the
following main sub-directories:

- The `/R` directory which holds all source files in the R language;
- The `/src` directory which holds all code in other languages which needs to be compiled on package installation;
- The `/inst` directory which generally holds bundles of external code, but may
  also include code used for cross-linking in compilation, including of other
  packages. Cross-linked code must be in an `/inst/include` sub-directory (as
  explained in [this section of the "*Writing R Extensions*"
  Manual](https://cran.r-project.org/doc/manuals/R-exts.html#Linking-to-native-routines-in-other-packages)).
  All of the following analyses only consider the `/inst/include` directory, and
  all references to the `/inst` directory imply this sub-directory only.
  Analyses excluded all other sub-directories within the `/inst` directory.
- The `/vignettes` directory which includes extended documentation. (Such
  documentation may also be placed in an `/inst/doc` folder, but this was
  ignored here.)
- The `/tests` directory containing test files.
- The `/data` directory containing data files used to implement or demonstrate
  package functionality.

The results which follow also distinguish between the two main kinds of R
functions:

- Exported functions intended to be called by users of a package; and
- Non-exported functions intended only to be called internally by other
  functions of a package.


### Code tagging with "ctags" and "gtags"

The [`{pkgstats}`](https://docs.ropensci.org/pkgstats) package is a static code
analysis tool specifically developed for R packages, with much of the
functionality extending from two general static analysis tools. Static code
analysis tools generally work by constructing parse trees which relate a
grammar describing one or more computer languages to each expression
encountered by tracing the code. An important first step is to "tag" each
expression, identifying the kind of expression and its scope, generally
implying its membership either of some component of the underlying grammar, or
some more local scope such as definitions within locally-sourced files.

[`{pkgstats}`](https://docs.ropensci.org/pkgstats) uses two open-source
libraries for code tagging and parse tree construction: "ctags" and "gtags".
The original "ctags" library is no longer maintained, and these analyses used a
maintained version called ["Universal ctags"](https://ctags.io) which,

> generates an index (or tag) file of language objects found in source files
> for programming languages.

This library was used here to tag each expression in the `R`, `src`, and
`inst/include` directories, providing the following data for each tagged item:

1. The tag itself, such as the name of a function, variable, or other object;
2. The name and path of the corresponding file;
3. The full content of the expression in which that tag was used (as a text string);
4. The kind of object (in `R` files, generally a `function`, `functionVar` or
   variable defined within a function, `globalVar` for global variables, or
   other objects defined by the `R` language; kinds of objects can be
   arbitrarily diverse in other languages);
5. The computer language in which that object was referenced; and
6. The start and end line numbers of the file in which that object is defined
   or referenced.

The "ctags" data for R files were also used to construct an "external call
network" of references to all R functions in all packages, including the
package being analysed, the base and recommended packages, and all other
contributed packages imported by each package. Functions were attributed to
packages by matching function names. Function names in R do not have to be
unique, and ["namespace conflicts"](https://conflicted.r-lib.org/) may arise
between packages implementing different functions with the same name. We
presumed that namespace conflicts most commonly arise in re-definitions of
functions initially defined in base or recommended packages, and in all such
cases we attributed a function to the external or contributed package over
definitions in the base or recommended packages.

The "gtags" library, itself part of the [GNU Global
library](https://www.gnu.org/software/global/), generates entries for every
expression, with the "tag" itself defining the environment for that expression.
This enables mappings to be made between every expression and its corresponding
tag. We used "gtags" to construct object reference networks across all computer
languages used in R packages (such as C, C++, or Python), to enable the
construction of "function call networks" within and between all languages.
While the terms "functions" and "calls" may not be appropriate for all computer
languages and/or classes or types of objects, they nevertheless reflect the
functionality of R code, and so are preferred here, even when referring to
other object relationships such as class inheritance mechanisms.

It is possible to cross-compile "gtags" with "ctags", to enable "gtags" to use
the more expansive language parsing abilities of "ctags", and to greatly extend
the range of languages able to be parsed by "gtags". In particular, "gtags"
does not not by default parse R code, yet does so when cross-compiled with
Universal "ctags". Cross-compiled installations of "gtags" are, however,
generally several times slower than simpler installations, and so these
analyses did not use a cross-compiled version. While this meant restricting
analyses to a smaller subset of potential languages, the output of "ctags"
itself nevertheless describes tags in all possible languages, with "gtags" only
used to map function call networks in languages other than R. Function-call
networks within R were extracted from the "ctags" output as described above,
and one additional function was written in the `{pkgstats}` package to link
calls within R code as defined by the "ctags" output to external objects
defined in other languages and specified by the "gtags" output. This enabled
full function-call networks to be constructed within and between different
languages used in R packages.

Data generated by "ctags" and "gtags" which were analysed here included:

- Numbers of internal and external functions in R.
- Numbers and kinds of all objects in all other languages.
- Numbers of Lines-of-Code for each function or object definition in each language.
- References from each function (or object) made to all other functions (or
  objects), including references made to all functions defined in other base,
  recommended, or contributed R packages.



### The `pkgstats` package

This sub-section describes additional data generated by
[`{pkgstats}`](https://docs.ropensci.org/pkgstats) beyond that extracted from
"ctags" and "gtags". The full list of all data generated by the package is
given in [the online documentation](https://docs.ropensci.org/pkgstats/), with
this sub-section only describing those aspects which were analysed here.

#### 'DESCRIPTION' files

All R packages must include a [Debian Control
File](https://www.debian.org/doc/debian-policy/ch-controlfields.html) ("DCF")
called "DESCRIPTION" [@hornik_too_many_R_pkgs_2012] which contains a subset of
standard DCF fields, including [a number of standardised and mandatory
fields](https://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file)
able to be analysed here. We extracted:

- Numbers of authors (as individuals with a specified role of "aut");
- Numbers of contributors (as individuals with a specified role of "ctb");
- Full entries of the "License" field specifying the type of license under
  which the software was released; and
- Entries in the "URL" field specifying one or more Uniform Resource Locators
  (URLs) for the package.
- Lists of all imported packages used to construct dependency networks between
  packages. (Neither required nor suggested packages were considered here.)

#### Translation files

R packages may include [files used to translate all messages issued by code into
other (human)
languages](https://cran.r-project.org/doc/manuals/R-exts.html#Preparing-translations).
These files are placed in a dedicated `/po` sub-directory, with file names
prefixed with standard prefixes (generally, but not necessarily, [ISO 639-1
codes](https://en.wikipedia.org/wiki/ISO_639-1)). This format enables
translations to be readily identified and extracted. `{pkgstats}` extracts a
list of all translations provided for each package.

#### Lines of Code (LoC)

[`{pkgstats}`](https://docs.ropensci.org/pkgstats) includes its own internal
tool (coded in C++) for counting Lines-of-Code (Loc). This tool produces output
similar to many common LoC tools, with additional data on:

1. Total numbers of code, comment, and blank lines;
2. Total numbers of characters in code lines, along with total numbers of
   white-space characters, to enable metrics of proportional white space; and
3. Code indentation, including identification of tab-indentation.

These white-space and indentation metrics were developed to enable
quantification of aspects of code outlay and design.

#### Function-level analyses

The "ctags" and "gtags" output described above provides data on the start and
end points of each function definition, along with names of associated files.
These data were used to provide estimates of average LoC per function, and
numbers of function definitions per file. (Where, as explained above,
"function" is used here as generic label for any object in any language, such
as class definitions.)

Each exported function in an R package must have a corresponding documentation
file in the `/man` directory of the package with the suffix, `.Rd` for "R
documentation". [`{pkgstats}`](https://docs.ropensci.org/pkgstats) also
statically parses these files with [the `parse_Rd` function of the recommended
`{tools}`
package](https://stat.ethz.ch/R-manual/R-devel/library/tools/html/parse_Rd.html).
For the present analyses, this enabled identification of the number of
parameters for each function, and the number of documentation characters for
each parameter. Total length of documentation for each function was also
quantified as the number of lines in the output produced by converting the
result of `parse_Rd` to text (via the `tools::Rd2txt` function).


### Network Analyses

Two distinct kinds of network analyses were performed here: *inter-package*
analyses of dependency networks between packages [akin to
@seven-pkg-networks-2019], and *intra-package* analyses of the function call
networks extracted from the "ctags" and "gtags" data described above.

#### Inter-Package Network Analyses

The 'DESCRIPTION' files of R packages must specify all external packages which
a package imports. These data can be used to construct a full dependency
network between all packages. The results below present the following measures
derived from package dependency networks, all of which were calculated with the
`{igraph}` package [@igraph].

1. Numbers of packages which are not imported by any others - the terminal
   vertices in a dependency network; 
2. Average "in-degree" of network vertices, or average numbers of times each
   package is imported by others;
3. The average *betweenness centrality* of each edge, which is the number of
   times that edge is traversed in connecting every package to every other
   package in the network;
4. The network-level *degree centrality*, which is a measure of vertex degree
   standardised to the overall size and structure of the network
   [@network-centrality-79].
5. A measure of the overall "size" of the network as the average distance
   between all pairs of vertices.

Betweenness centrality provides insight into how centralised the network is,
with higher values reflecting networks in which connections frequently traverse
a common, central region. The network-level degree centrality reflects the
extent to which vertices all have a relatively high in-degree; networks in
which all networks have an equal in-degree have no effective centre, and so
have a degree centrality of zero. In contrast, networks with a few
highly-connected central vertices and many vertices with low in-degree will
have a high degree centrality. These two centrality metrics provide slightly
different insights: betweenness centrality will increase to the extent to which
a network manifests a single, common centre; degree centrality will increase to
the extent that networks become more centralised in general, regardless of
whether or not any singly identifiable centre forms.

Networks with low degree centrality are readily traversable, and so will
generally have lower average distances between all pairs of vertices. The
distance metric nevertheless may offer additional insight, and will for example
be higher independent of degree centrality for networks with extended
peripheral connections. Finally, we note that clusters or local network
communities were not considered here, as the dependency networks of CRAN
packages are almost always so highly connected that the largest connected
cluster represents over 99% of the network.

#### Intra-Package Network Analyses

Intra-package networks were constructed from the function call networks
described above, and included overall package networks connecting code in all
sub-directories, as well as network analyses of only those components
representing individual sub-directories, here constrained to network analyses
of both `/R` and `/src` code. Function call networks within individual packages
are commonly structured in several distinct clusters, and thus numbers of
clusters provided an important first metric for intra-package analyses.
Intra-package analyses considered the following metrics:

1. Ratio of numbers of edges to numbers of vertices.
2. Numbers of distinct clusters between all functions or objects across all
   languages.
3. The betweenness centrality of the function call network.
4. Numbers of terminal vertices (functions which do not call any other
   functions).
5. The average vertex degree.


### Coupling Instability

[Coupling Instability](https://en.wikipedia.org/wiki/Software_package_metrics)
is an important concept in the analysis of software dependency networks
[@martin-agile-2002], and depends in turn on numbers of so-called *afferent*
and *efferent* couplings. For any given package, these are defined as:

- *Afferent Couplings* as numbers of functions in other packages which depend
  on functions within the package.
- *Efferent Couplings* as numbers of functions from other packages which the
  package depends on.

In other words,

- *Afferent* couplings are numbers of *inbound* edges from all other packages
  to a given package, while
- *efferent* couplings are *outbound* edges coupling that package with all
  other packages.

Respectively denoting afferent and efferent couplings by $n_a$ and $n_e$, the
coupling instability, $I$, is defined as $I = n_e / (n_e + n_a)$. Packages
which depend on many external calls (high efferent couplings), yet upon which
few other packages depend (low afferent couplings) thus have a high coupling
instability, while packages upon which many other packages depend, yet which
themselves depend on few other packages have a low coupling instability. The
analyses below quantified coupling instability for each package from the
dependency networks, using total numbers of function calls between all
packages, in order to estimate the average coupling instability of the entire
network.

We also adapted this measure of coupling instability *between packages* to a
measure of *internal* coupling instability [@almugrin_coupling_2015] between
the individual files of one package. Packages with high internal coupling
instability make many calls between individual files, while packages with low
instability make more calls within single files, and relatively fewer between
them.


### Statistical Analyses

The following results depict and interpret qualitative trends and patterns,
without implementing or reporting values for any statistical tests. Data were
sufficiently large (N > 105,000) to ensure that all of the reported results
were entirely significant in frequentist terms. There are two further important
aspects to note in regard to statistical analyses detailed below.

#### Temporal Analyses

Most of the following results depict the evolution of CRAN software over time,
in two main ways:

1. As annual developments averaged over all packages; or
2. As developments for individual packages over sequences of releases.

Several of the following results are accordingly divided into the corresponding
sub-sections of "Annual Developments" and "Sequential Releases," respectively
referring to these two modes of analysis. Annual developments aggregate values
over all packages for each year, while sequential developments aggregate values
over each sequential release, so that the first versions of all packages are
aggregated for a release sequence of one, second versions for release sequence
two, and so on. Annual developments thus capture the collective development of
the system as a whole, while sequential developments capture the development of
individual packages.

For continuously updated repositories like CRAN, annual developments can be
captured in the following two primary ways:

1. Through considering each year to represent the state of CRAN at that time,
   and thus to include latests releases of all packages for that year,
   regardless of how long ago a package may previously have been updated.
   Annual estimates derived this way are referred to here as **CRAN
   snapshots**.
2. Through considering each year to represent only the state of CRAN in terms
   of packages uploaded in that specific year, disregarding any packages
   uploaded in prior years. Estimates derived this way are referred to simply
   as **annual** values.

Under the plausible assumption that rates of package updates follow some kind
of Poisson-like process, the ages of packages at any given time will be
exponentially distributed, analogous to distributions of waiting times for
Poisson processes. This means that values derived using **CRAN snapshots** will
generally reflect exponentially-smoothed versions of **annual** values. Many of
the graphical results which follow depict results dervied using both of these
approaches, in which:

- solid lines represent annual values, which are generally noiser versions of
- dashed lines, which represent effectively exponentially-smoothed versions of
  the same data using CRAN snapshots for each year.

Where no additional interpretations are given, solid lines in all of the
results that follow represent annual values, while dashed lines represent
results derived from CRAN shapshots. See Fig. 1A immediately below, for an
example. Where also not otherwise mentioned, all reported values refer to
(generally noisier) annual values, and not to values derived from (generally
smoother) CRAN snapshots.


### Distributional properties and mean values

Almost all statistics described above, and presented in the results below, were
approximately log-normally distributed. References in any of the following
results to mean values thus imply values calculated as `10^mean(log10(x))`. The
use of direct mean values did not generally alter any of the qualitative
conclusions which follow, yet resulted in many cases in less distinct or smooth
trajectories or results.

## Results

Many of the following results reveal pronounced changes broadly centered around
2010. It is important in interpreting such results to note that the largest
public code hosting platform, GitHub, launched in 2008. This changes from that
year onward are very likely influenced by the increased public accessibility of
code, as discussed further below.

### Metadata

Numbers of both authors and contributors have increased over time (Fig. 1A),
with contributors having been rarely acknowledged at all prior to 2010,
increasing to an average of just under one acknowledged contributor per package
in 2021. Numbers of unique licenses primarily reflect numbers of ways of
declaring licenses, rather than numbers of actual licenses (for example,
"GPL >= 2.0" is different to "Any GPL license version 2 or higher", although
both clearly refer to the same license). Figure 1B shows a roughly linear
increase in license declarations up to around 2007, followed by a pronounced
drop and progression into a roughly stable range of somewhere over 50 distinct
entries. The different ways of specifying the three versions of GPL licenses
have accounted for over 83% of all CRAN packages, with the second most common
type license being MIT, at 9.6%, followed by BSD at 2.0%. One of these three
classes of licenses are used in 95% of all CRAN packages.


```{r fig01, child = "figures/fig01.Rmd", eval = TRUE, echo = FALSE}
```

```{r licenses, echo = FALSE}
datafile <- file.path (here, "data-raw", "pkgstats-results.Rds")
x <- load_pkgstats_data (datafile, raw = TRUE, latest = FALSE)
index <- which (x$year > 2010)
lic <- sort (table (x$license [index]), decreasing = TRUE)
lic <- data.frame (license = names (lic),
                   n = as.integer (lic))
#knitr::kable (lic [1:10, ], caption = "**Table 1.**")

index <- grep ("GPL|general\\spublic\\slic", lic$license)
prop_gpl <- sum (lic$n [index]) / sum (lic$n)
index <- grep ("BSD", lic$license)
prop_bsd <- sum (lic$n [index]) / sum (lic$n)
index <- grep ("MIT", lic$license)
prop_mit <- sum (lic$n [index]) / sum (lic$n)
prop3 <- prop_gpl + prop_bsd + prop_mit
```

The practice of translating messages within R packages into other languages has
steadily declined in recent years (Fig. 2A), suggesting a pronounced increase
in acceptance over the last 15 or so years of English as a globally standard
language, and a concomitant decrease in active acknowledgement of other
languages. (The `en@quot` translation entry in Fig. 2A is described in the [*R
Installation and Administration*
Manual](https://cran.r-project.org/doc/manuals/R-admin.html#Localization-of-messages)
as a translation which, "can be used in a UTF-8 locale to have American error
messages with pairs of single quotes translated to Unicode directional
quotes.") Rates of decrease since 2008 equate to 1.5% fewer packages per year
including translations, from a total of just over 20% of all packages in 2008,
to barely over 1% in 2021. While rates of decrease have slowed somewhat in
recent years, extrapolation of the preceding five years nevertheless suggests
that the practice of offering translations will effectively disappear before
the end of the coming year (2023).

```{r fig02, child = "figures/fig02.Rmd", eval = TRUE, echo = FALSE}
```


Analyses of URLs provided in package 'DESCRIPTION' files clearly reveal an
abrupt break after around 2010 with the advent of online code repositories
(Fig. 2B). GitHub has always dominated, while r-forge has declined
progressively since around 2015. The most notable increase has been the
emergence of rOpenSci as provider of the only URL to come close to within
1/20th of the popularity of GitHub over the past few years.


### Package Structure and Content

The temporal development of numbers of files manifest several notable
characteristics (Figure 3). Unsurprisingly, R packages have always been
dominated by files in the `R/` directory, numbers of which increased
considerably up to around 2010, after which they have generally stabilised at
mean values of around 13-15 files per package (Fig. 3A). The `/vignettes`
directory is the only place within R packages in which numbers of files have
remained relatively constant over the preceding 20+ years. Packages generally
had very few files in the `inst` directory prior to 2010, after which they
increased until around 2015, before decreasing again more recently. The two
sub-directories in which numbers of files have increased most significantly are
`/src` and `/tests`, with the latter increase particularly distinct, clearly
indicating that packages have become progressively better tested.


```{r fig03, child = "figures/fig03.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Figure 3B shows equivalent changes within individual packages across successive
releases. Numbers of files generally progressively increase as packages mature,
with especially pronounced increases in the `/R` and `/inst` directories, the
latter somewhat offset after around 15 releases by decreases in the `src`
directory. These changes in `/src` and `/inst` directories in the later phases of
package maturation may reflect restructuring code from the `/src` to the
`/inst` directories in order to allow cross-compilation by other packages.
Numbers of test files generally increase out to around 15 releases, after which
they generally stabilise. The only directory in which numbers of files do not
notably increase as packages mature is `/vignettes`.


### Code Metrics

#### Annual Developments

Figure 4 shows the temporal evolution of a number of code metrics. Lines of
Code ("LoC") in the primary `/R` and `/src` sub-directories broadly increased
up to around 2005-2010, after which time LoC in these directories have slightly
decreased, converging on just over 600 lines in both `/R` and `/src`
directories. These trends are broadly reflected in LoC per function (Fig. 4B),
excepting the early years of CRAN, during which functions often had well over
100 lines each, especially `/src` functions defined in other languages (in those
years, primarily Fortran and C). That panel, as well as Fig. 4C, distinguishes
between the two primary kinds of R functions, exported and non-exported. LoC
per function have remained broadly stable for almost 20 years, at around 30
lines for all function types and languages. The slight decrease discernible
since around 2015 amounts to one LoC less for exported, non-exported, and
`/src` functions every 3.4, 8.5, and 1.5 years, respectively.

Total numbers of R functions initially increased until around 2007, peaking at
just under 30 exported and over 50 non-exported functions per package (Fig.
4C). Numbers of exported R functions have decreased since then to around 17
exported and 40-45 non-exported functions per package in 2021. Numbers of
functions defined in `/src` directories have followed broadly similar
trajectories to exported `/R` functions, slightly decreasing since the early
2000's to between 30-40 functions. Numbers of functions per source file in both
`/R` and `/src` directories have nevertheless progressively decreased since the
early 2000's to now amount to less than four `/R` functions and just over five
`/src` functions per file (Fig. 4D).


```{r fig04, child = "figures/fig04.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

#### Sequential Releases

Figure 5 shows results equivalent to Fig. 4, but for the development of the
respective metrics with each sequential release of a package, rather than
annual developments. Lines of code generally increase as packages mature, with
mean numbers of lines in the `/R` directory increasing tenfold from under 400
for first releases to over 5,000 in packages with 100 or more releases. LoC in
`/inst` directories also tend to increase as packages develop, although to a
lesser extent, and only becoming notable after around 50 releases. Beyond the
first few releases, there are always fewer LoC in `/src` directories than in
`/R` directories. This contrasts with the annual aggregate results of Fig. 4A,
which suggest more LoC in `/src` than `/R` directories until around 2007, and
roughly equal numbers since then. This difference reflects the fact that most
packages have only one or two releases (the distribution of numbers of releases
is not shown here, but manifests a very smooth exponential decrease), so Fig.
4A is dominated by packages in a very early state of development, for which LoC
in `/src` often exceed numbers in `/R`. Similar to patterns for `/src` and
`inst` directories in Fig. 3B, decreases in LoC in `/src` directories in the
later phases of package maturation may reflect restructuring code to `/inst`
directories. This clear peak in LoC in `/src` directories may in turn suggest
this is an approximate number of releases before other developers become aware
of the functionality of package `/src` directories. The clearest result of Fig.
4A is manifest in total LoC, which increases in a strikingly linear manner even
out to the 100th release of a package.

```{r fig05, child = "figures/fig05.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

These increases in LoC nevertheless corresponded to general decreases in LoC
per function with increasing numbers of releases (Fig. 5B). In all directories,
LoC per function either slightly increased or remained generally stable over
the first 50 or so releases, beyond which functions in all directories clearly
become considerably more streamlined, with LoC decreasing markedly out to the
100th release. Similar to the aggregate LoC measures of panel A, LoC in `/src`
directories manifest a distinct peak as packages matured, with LoC per `/src`
function peaking slightly earlier (after around 40 releases) than total LoC
(slightly over 50). The decreases in the latter portions of Fig. 5B are
nevertheless relatively minor, and amount to removing one LoC per function for
every 5, 7, or 18 releases for exported R, non-exported R, and source function,
respectively.

The increasing total measures of LoC of panel A combined with decreasing LoC
per function of panel B must mean that more functions are added as packages
mature, which is precisely what Fig. 5C reveals. Packages initially contain
less than ten exported functions on average, yet this increases over 10-fold
to over 130 by the 100th release. Numbers of `/src` functions are initially
higher, at around 20, and increase relatively less than equivalent `/R`
functions, to around 100 after 100 releases. Numbers of non-exported `/R`
functions manifest the most pronounced
increase, of over 15 times from 20 functions for initial releases, to well over
300 for the 100th release. Finally, numbers of functions per file show no clear trend
for `src` code, remaining broadly stable at around six functions per file (Fig.
4D). In contrast, `/R` code files begin with 3-4 functions per file, and
increase progressively to around eight functions per file after 100 releases,
in the context of Figs. 4B-C clearly mostly due to breaking large non-exported
functions down into multiple, smaller functions.

Numbers of functions depicted in Fig. 4C actually count any arbitrary code
objects in all languages contained in `/src` directories, and so corresponds
directly to the "modules" posited to increase according to the inverse-square
"law" of software evolution [@Turski96;@software-evolution-97;@Turski02]. The
defining qualitative feature of such inverse--square growth is an initially
highly concave form, with rates decreasing notably as packages mature. The
trajectories of Fig. 4C appear in contrast strikingly linear, all manifesting
trajectories which would be very poorly described by such an inverse-square
form.

```{r turski, echo = FALSE, eval = FALSE}
datafile <- file.path (here, "data-raw", "pkgstats-results.Rds")
x <- load_pkgstats_data (datafile, raw = TRUE, latest = FALSE) |>
        group_by (package) |>
        mutate (seq = seq_along (package))
x$loc_R [which (is.na (x$loc_R))] <- 0L
x$loc_src [which (is.na (x$loc_src))] <- 0L
x$loc_inst [which (is.na (x$loc_inst))] <- 0L
x$loc_total <- x$loc_R + x$loc_src + x$loc_inst

x_rel <- x |>
    group_by (seq) |>
    filter (seq <= 100) |>
    summarise (
        n = logmean (n_fns_r_exported + n_fns_r_not_exported + n_fns_src, na.rm = TRUE))

s_inv <- cumsum (1 / x_rel$n ^ 2)
E <- mean ((x_rel$n - x_rel$n [1]) / s_inv)
fit <- rep (x_rel$n [1], nrow (x_rel))
for (i in seq (nrow (x_rel)) [-1]) {
    fit [i] <- fit [i - 1] + E / (fit [i - 1] ^ 2)
}
x_rel$fit <- fit
x_rel <- pivot_longer (x_rel, c (n, fit))

ggplot (x_rel, aes (x = seq, y = value, colour = name)) +
    geom_line ()
    #geom_smooth (method = "loess", formula = "y ~ x")
```


### Package Imports and Exports

Like the "standard" libraries for the python language, R has a core set of
"base" and "recommended" packages. The function call networks extracted by
`pkgstats` enable counting numbers of calls to each of these groups of
packages, as well as to "contributed" packages hosted on CRAN.

#### Annual Developments

Figure 6A shows the change over time in proportions of calls to these three
groups of packages, revealing a recent tendency (since around 2015) of fewer
calls to base R functions, from over 80% of all function calls in the early
2000s, to below 70% in the previous two years. This decrease has been offset by
greater numbers of calls to functions in contributed packages, while calls to
recommended packages have remained generally stable at around 20%. Although
calls to contributed packages have always represented the lowest proportion of
these three groups, this recent increase nevertheless places them on almost
equal proportion (at 12%) to calls to recommended packages (at 18%).

```{r fig06, child = "figures/fig06.Rmd", eval = TRUE, echo = FALSE}
```

Figure 6B shows the "coupling instability" of packages over time. As explained
above, this is a measure of the extent to which packages depend on external
functionality (efferent couplings) without other packages in turn depending on
them (afferent couplings). Packages on CRAN were largely stable until around
2010, at a coupling instability of around 0.5, meaning numbers of functions
from each package which were imported by other packages were roughly equal to
numbers of external functions each package imported. Instability has increased
markedly since that time, indicating that packages have become increasingly
dependent on external functionality, while the average package is less likely
to provide functionality used by other packages. The coupling instability over
the preceding two years of around 80% implies that packages make on average
eight calls to other packages for every two calls made to that package.

As another aggregate measure of changes in package imports,
@seven-pkg-networks-2019 analysed Gini coefficients, which are standardised
aggregate differences in numbers of imports between packages. Systems in which
all packages import equal numbers of dependencies have a Gini coefficient of
zero, while systems with maximally heterogeneous numbers of imports have a Gini
coefficient of one. While they concluded that Gini coefficients have increased
over time for all seven of the package distribution systems they studied
(including CRAN), at least over their time period of 2012-2017, our equivalent
results are depicted in Fig. 6C, revealing a profound dependence on how annual
values are defined and calculated. Using "annual values" through aggregating
statistics only from packages uploaded in each year (solid lines) yields Gini
coefficients which decrease over time, while calculating annual values as "CRAN
snapshots" as the entire system would have existed for each year (dashed lines)
yields Gini coefficients which increase over time. Their results appear to
qualitative accord with our "CRAN snapshot" values for package dependency
networks, although our values are only around half of theirs, suggesting that
they perhaps neglected a final divisor of 2 in their calculations.

Moreover, that panel depicts Gini coefficients calculated both from numbers of
imported packages, and total numbers of external function calls. Numbers of
function calls will only equal numbers of imported packages when only one
function is used from each package, otherwise numbers of function calls must be
greater, leading to larger Gini coefficients of inequality in numbers of
external function calls between packages. Other than this expected difference
in scale, results from both single-package imports and numbers of functions
were qualitatively similar.

Finally, figure 6D depicts changes in numbers of unique function calls from
each package to the top ten contributed packages, defined as the ten packages
with the largest total number of unique function calls from all packages
throughout the history of CRAN. The top two packages of {ggplot2} and {dplyr}
account for `r prop_top2`% of all function calls from all contributed packages
over the time shown. Numbers of function calls are shown on a logarithmic
scale, with numbers of calls to each of these packages increasing exponentially
between 2013 and 2018, before levelling off or even slightly decreasing.

#### Sequential Releases

The first two panels of Figure 7 show results equivalent to Figs 6A-B, but for
changes with progressive releases of each package. Packages tend to make
progressively fewer calls to base R functions as they mature, although this
decrease is relatively less pronounced than the overall decrease over time of
Fig. 6A. However, in stark contrast to Fig 6A, in which decreases over time
were offset by relative increases in calls to contributed packages, decreases
in calls to base R functions as packages mature are offset by relative
increases to calls to recommended packages, while calls to contributed packages
actually decrease. Such changes become relatively less pronounced as packages
mature, stabilising after around 50 releases at around 75% of all function
calls to base R, and just under 25% to contributed packages.

```{r fig07, child = "figures/fig07.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Figure 7B shows the average trajectory of coupling instability for individual
packages across the depicted numbers of sequential releases, which decreases
very progressively as packages mature, as should be expected if packages are
increasingly likely to be imported by other packages (that is, as incoming or
afferent couplings increase). That figure also shows average numbers of
efferent couplings, or numbers of outward calls from each package to other
packages, which stay largely stable as packages develop. Increases in package
stability thus arise as packages develop purely through being imported as
dependencies by increasing numbers of other packages. This in turn suggests
that the best way to counteract the increasing coupling instability of CRAN as
a whole depicted in Fig. 6B would be to ensure that packages remain
progressively developed, rather than abandoned (or archived) after only a few
releases.

Finally, Fig. 7C shows progressions of both packages and individual functions
being imported into other packages as a function of release sequence. The
number of packages importing a package increases progressively with numbers of
releases, as was already clear from Fig. 7B. Packages with less than ten
releases are, on average, imported by very few other packages, while packages
with 40 or more releases are imported by ten other packages on average. The
second line on that figure nevertheless reveals that packages import on average
only 1-2 functions from any given package, and that numbers of functions
imported by other packages increase only marginally as packages mature.

Coupled with the observed increases in numbers of exported functions as
packages mature depicted in Fig. 5C, the slight increase in numbers of
functions imported by other packages nevertheless suggests a relationship
between total numbers of functions exported by a package, and numbers imported
by other packages. Indeed, taking only the latest versions of all packages and
relating these two values reveals that other packages are likely to import one
additional function on average for every 2.8 additional functions exported by
a package.

### Network Analyses

#### Annual Developments

The first two panels of Fig. 8 show the temporal development of the CRAN
package dependency network, in both cases revealing that most network metrics
have broadly stabilised over the preceding five or so years, and that
variations were much more pronounced prior to around 2015. The proportion of
terminal vertices, or packages not imported by any other packages, has remained
broadly stable at around 55-60% of all packages. The mean vertex degree of the
dependency network has nevertheless progressively increased, especially since
2015, indicating that those packages which are imported by others have been
imported by increasing numbers of other packages (Fig. 8A).

```{r fig08, child = "figures/fig08.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Such an increase in average numbers of imports must increase the overall
connectivity of the dependency network, with Fig. 8B showing concomitant
decreases in both centrality metrics over time. Average distances between each
pair of packages in the network increased notably up to around 2013, after
which time they have progressively decreased. Since numbers of terminal
vertices have remained generally stable, while centrality has decreased, the
initial increase in mean distance likely reflects terminal vertices becoming
nevertheless further away, for example through the network evolving a number of
distinct centres. The more recent decrease in mean distance may then reflect an
equivalent centralisation of the dependency network.

The lower two panels of Fig. 8 depict the evolution of function call networks
within individual packages. Fig. 8C shows the ratio of numbers of edges to
numbers of vertices, with higher values indicating more densely connected
networks. Since around 2005, network connections within R functions, whether
exported or not, have remained largely constant, with each function being
called by around 5-6 other functions. Connections between functions in `/src`
directories have in contrast decreased considerably, with each `/src` function
(or object) now being "called" (or referenced, inherited, or any other method)
by just over one other function. Ratios of edges to vertices in the full
function call network extending between all directories (including `/inst`) has
progressively declined from over 4 calls per function to less than 3 in recent
years. Function call networks form on average around three distinct clusters
for each package, peaking at over 3.5 in 2007 before more recently decreasing
to just over 2.5 clusters.

The final panel (Fig. 8D) shows average centrality metrics from function call
networks, revealing a marked stability, except for numbers of terminal edges (in
that context, meaning numbers of functions which call no other functions),
which have decreased since around 2005 from around 12 per package to around 7.


#### Sequential Releases

Analyses of sequential releases can only meaningfully be applied to the
function call networks of Figs. 8C-D, and so Fig. 9 depicts equivalent values
only for those two panels. Fig. 9A reveals that function call networks tend to
become more densely connected as packages mature, and more so in `/src` than in
`/R` directories. The aggregate increase contrasts strikingly with the
equivalent and generally decreasing average tendency over time of Fig. 8C. This
contrast can again be explained by the fact that most packages only have one or
two releases, and so packages on CRAN have on average become less internally
connected over time as recently-released packages have increasingly dominated.
The decrease in package connectivity over one year of Fig. 8C corresponds to an
equivalent increase in Fig. 9A after 224 releases, indicating that decreases in
internal connectivity through increasing dominance of recently-released
packages far outweighs compensatory decreases through packages maturing.

```{r fig09, child = "figures/fig09.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

Finally, centrality metrics change dramatically as packages mature (Fig. 9B),
in stark contrast to the annual changes of Fig. 8D. Packages develop greater
numbers of terminal edges, yet retain almost identical vertex degrees through
becoming more centralised as they develop. One way such an effect could be
achieved would be through transforming a package from having several distinct
clusters, each internally highly connected yet only loosely coupled to other
clusters, progressing towards having fewer numbers of more highly centralised
clusters, with increasing numbers of single connections out to terminal
vertices.

### Code formatting and Documentation

We conclude these results with analyses generated by the internal Lines-of-Code
routines of `pkgstats`, along with static analyses of the function
documentation (`.Rd`) files. Proportions of blank and comment lines have
remained markedly similar in both `/R` and `/src` directories over time, except
for comment lines in `/R` code, which have increased dramatically since around
2010. This roughly corresponds to the first release of the `{roxygen2}` package
which has indubitably done more than any other package to standardise
documentation of R functions. This increase in `/R` documentation is likely a
direct reflection of the widespread adoption of `{roxygen2}` as the
documentation standard for R packages.

```{r fig10, child = "figures/fig10.Rmd", eval = TRUE, echo = FALSE, warning = FALSE}
```

The relative proportion of white space in code lines has increased consistently
yet very slightly over time, amounting to an increase from slightly under 13%
to slightly over 14.5%. This value nevertheless describes average changes for
every line of code, and so amounts to one additional space for every 67 code
characters. The most dramatic development of Fig. 10B is clearly the decrease
in the proportion of files with tab-indentation, from well over 60% before the
year 2000 to barely over 10% today. Ignoring tabs, code indentation increased
until around 2005-2010, remaining constant at 3-3.5 spaces for many years
before more recently declining to well under 3 spaces.

Each R function in 1998 had an average of six parameters, yet this declined
very rapidly to under four within two years (Fig. 10C). Numbers of parameters
have progressively increased since then, yet still barely exceed an average of
four parameters per function. Parameter documentation has followed an almost
identical trend, increasing from under 70 characters per parameter to just over
80. In contrast, total numbers of documentation lines per function initially
increased until around 2010, at almost 60 lines, before decreasing more
recently to 50 lines per function or less.

The equivalent results analysed as a function of release sequence rather than
year reveal that functions become markedly better documented as packages mature
(Fig. 10D), although not through additional documentation of parameters.
Analogous to preceding results, the recent decrease in documentation lines per
function likely reflects an increasing prevalence of recently released packages
which outweighs increases in function documentation as individual packages
mature.

Finally, contrasting panels C and D of Fig. 10 also reveals a likely influence
of increasing dominance of recent packages on numbers of parameters per
function. While this number has increased consistently over recent years (Fig.
10C), numbers of parameters also decrease markedly as packages mature, equating
to an average of one parameter fewer in all functions after 58 releases. The
equivalent annual effect from Fig. 10C would translate to one additional
parameter every 46 years. The average interval between package releases over
the duration of CRAN has been 207 days, according to which 58 releases would
take 33 years. That comparison suggests that the effects of packages maturing
in decreasing average numbers of parameters per function (still) slightly
out-competes the counteracting effect of increasing average numbers of
parameters per function through the increasing dominance of recently released
packages.

## Discussion

These results reveal a number of metrics which appear to have evolved in one
direction when collectively measured across all CRAN packages, yet which tend
to evolve in opposing directions within the evolution of individual packages.
An example is the metric of "coupling instability" which has increased markedly
for all packages since around 2010 (Fig. 6B), yet which decreases in any
individual package from near one on first release (due to new packages being
unable to be used or depended on by other packages) to near zero after around
100 releases. Additional examples arose in proportions of calls to base R
functions, which have collectively decreased over time (Fig. 6A), from over 80
to under 70%, while calls to contributed packages have collectively increased
from under 1% to almost 15% in 2021. While individual packages tend to use
proportionally fewer calls to base R functions as they mature, they also use
proportionally fewer calls to contributed packages, and substitute both of
these with increasing proportions of calls to recommended packages (Fig. 7A).
Simpler examples also arise in variables like numbers of R functions per file,
which have decreased consistently over CRAN as a whole (Fig. 4D), yet which
increase progressively as individual packages mature (Fig. 5D).

These general patterns indicate the ubiquity of a dual dynamic between
individual packages tending to develop or evolve in one particular direction,
yet CRAN as a whole collectively developing in opposing directions due to
becoming increasingly dominated by less mature packages in relatively
preliminary states of development. It is of course generally not
straightforward for many metrics considered here to determine whether an
observed trajectory might be a positive development for CRAN as a whole or not.
The example of coupling instability nevertheless provides one metric with a
clear understanding, and for which high values are generally considered
undesirable [@martin-agile-2002]. In this context at least, the ongoing
development of CRAN is defined by a dynamic balance between the stabilising
influence of mature packages, and converse and potentially destabilising
influences of increasing numbers of recently contributed packages.

However, even balances between variables like these which are relatively easy
to interpret must be considered carefully. For example, the preceding results
made several comparisons through quantifying relative rates of change of such
opposing tendencies. Direct comparisons presume more recent packages to have
equal weight or influence on the overall system dynamic as do more mature
packages. It may be more appropriate to implement some form of weighted
analyses, for example, through weighting the contributions of individual
packages by numbers of dependent packages. Although such analyses lie beyond
the scope of the present work, the evident tensions between individual and
collective dynamics represent a key finding of the present work, and one which
could and should be extended in future analyses through considering such
additional influences as weighted contributions of individual packages to the
collective development of software systems.

### Quantifying temporal development of software systems

The preceding analyses contrasted and compared results derived from two
distinct ways of quantifying "annual" statistics. The "snapshot" values
considered the collective properties of the system as it existed in each year,
including latest versions of all packages regardless of when those packages
were last updated. In contrast, "annual" values only considered software
actively uploaded in each year. As stated at the outset, snapshot values may be
generally presumed to reflect exponentially-smoothed versions of annual values,
and so these two approaches to aggregating annual values ought to qualitatively
agree, with snapshots merely being an effectively smoothed version of annual
values. Such an assertion can nevertheless never be more than a generalisation,
and the particular statistical properties of a system may manifest different
patterns.

Such contrasting patterns arose in the annual developments of Gini coefficients
of Fig. 6C, which presented coefficients both for inequality between numbers of
package dependencies, and numbers of individual functions from those
dependencies. Calculating annual values only from software uploaded in each
year ("annual" values; solid lines in that figure) yielded Gini coefficients
which have progressively decreased over the last two decades, while using
"snapshot" values produced opposing trajectories of increasing Gini
coefficients (dashed lines). 

@seven-pkg-networks-2019 previously claimed that Gini coefficients for all
seven package distribution systems they studied had increased over time. These
coefficients measure relative inequality in the distributions of numbers of
package imports, with larger values reflecting systems with greater disparities
between packages in numbers of imports. While @seven-pkg-networks-2019 did not
explicitly describe how they defined their annual figures, all data were
derived from the "meta-platform" `libraries.io`, which collates software from
several distribution systems and computer languages. Use of data from this
platform would only enable "annual" rather than "snapshot" values to be
calculated. The present results then appear to contradict theirs, through
revealing annual Gini coefficients to have decreased over the preceding two
decades, rather than increasing as they concluded (albeit in their case over a
more narrow temporal range of 2012-2017). Quantifying annual values as
snapshots of the entire system, including latest versions from all prior years,
led to opposing trajectories of increasing Gini coefficients. These conflicting
patterns prevent any firm conclusions regarding temporal evolution of Gini
coefficients, but do reveal the critical importance of precisely specifying the
methods used to aggregate annual values.



### Dependency Networks

The results of Fig. 6C for the Gini coefficients of inequality in both package
dependencies and function call networks revealed contrasting patterns
dependent on how annual values were aggregated. Gini coefficients are
calculated as sums of absolute pairwise differences between individual items.
For package dependencies, for example, these are pairwise differences between
all packages in numbers of imports, standardised by the mean number of imports
and a scaling coefficient such the result is bounded between zero (no
inequality) and one (maximal inequality).

For discrete, non-negative variables such as counts, Gini coefficients must
generally increase with the scale or maximal values of those variables. 

```{r gini-with-n, echo = FALSE}
xmax <- 1:10
n <- 1000
g <- vapply (xmax, function (i) {
                 #p <- exp (-(1:i))
                 #p <- p / sum (p)
                 p <- rep (1 / i, i)
                 s <- sample (1:i, size = n, replace = TRUE, prob = p)
                 sum (abs (dist (s, method = "manhattan"))) /
                     (2 * n ^ 2 * mean (s))
        }, numeric (1))
g <- data.frame (n = xmax,
                 gini = g)
ggplot (g, aes (x = n, y = gini)) +
    geom_line ()
```

### Future Work

> we need better data to do computational statistics on statistical computing
solutions: certainly, the CRAN package repository should be an extremely
valuable resource for the community, both for gathering and analyzing such
data.

@hornik_too_many_R_pkgs_2012

## References
