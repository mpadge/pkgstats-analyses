
@article{oss-evolution-2016,
    title = {Open Source Software Evolution: A Systematic Literature Review (Part 1)},
    author = {Chahal, Kuljit Kaur and Saini, Munish},
    year = {2016},
    journal = {International Journal of Open Source Software and Processes
        (IJOSSP)},
    volume = {7},
    number = {1},
    pages = {28-45},
    doi = {10.4018/IJOSSP.2016010101}
}

@article{pypi2019,
    title = {An Empirical Analysis of the Python Package Index (PyPI)}, 
    author = {Bommarito, Ethan and Bommarito, Michael},
    year = {2019},
    journal = {arXiv},
    volume ={1907.11073},
    eprint = {1907.11073},
    archivePrefix = {arXiv},
    primaryClass = {cs.SE}
}

@article{seven-pkg-networks-2019,
    title = {An empirical comparison of dependency network evolution in seven
        software packaging ecosystems},
    author = {Decan, Alexandre and Mens, Tom and Grosjean, Philippe},
    year = {2019},
    journal = {Empirical Software Engineering},
    volume = {24},
    pages = {381--416},
    doi = {10.1007/s10664-017-9589-y},
    url = {https://doi.org/10.1007/s10664-017-9589-y}
}

@article{analytics-so-what-2013,
    author = {Menzies, Tim and Zimmermann, Thomas},
    journal = {IEEE Software},
    title = {Software Analytics: So What?},
    year = {2013},
    volume = {30},
    number = {4}, 
    pages = {31-37},
    doi = {10.1109/MS.2013.86}
}


@inproceedings{software-evolution-97,
    author = {Lehman, M.M. and Ramil, J.F. and Wernick, P.D. and Perry, D.E. and
        Turski, W.M.},
    booktitle = {Proceedings Fourth International Software Metrics Symposium},
    title = {Metrics and laws of software evolution-the nineties view},
    year = {1997},
    volume = {},
    number = {},
    pages = {20-32},
    doi = {10.1109/METRIC.1997.637156},
    note = {It is a preliminary report of a larger project, but one which seeks
        to determine whether "laws" set out from the early 70s, might still
        apply in the late 90s. The "laws" are discerned from analyses of
        "software metrics", and the paper concludes that these laws still do
        apply

        > software evolution processes are and must be treated as being
        > feedback-driven and constrained systems [leh74,78].

        The laws are:

        1. Continuing Change
        2. Increasing Complexity (unless work is done to maintain or reduce)
        3. Self Regulation (product and process measures are close to normal)
        4. Conservation of Organisational Stability (invariant work rate)
        5. Conservation of Familiarity (excessive growth reduces familiarity, so growth
           is constrained)
        6. Continuing Growth (in functional content)
        7. Declining Quality (unless rigorously maintained and adapted)
        8. Feedback System (systems must be treated as such to achieve significant
           improvement).

        They apply a simple "inverse square" model, attributed to Turski, to fit
        observed rates of increase in size, *s*, over time:

        $s_i = s_{i - 1} + \bar{E} / s_{i - 1} ^ 2$,

        where $\bar{E}$ is a model parameter calculated either as 

        $E_i = (s_i - s_{i-1})s_{i-1}^2$, or
        $E_i = (s_i - s_1) / (\sum_{k=1}^{i-1} 1 / s_k^2)$

        This could be directly fitted to observed data here.}
}


@article {Turski96,
    author = {W. M. Turski},
    journal = {IEEE Transactions on Software Engineering},
    title = {Reference Model for Smooth Growth of Software Systems},
    year = {1996},
    volume = {22},
    number = {08},
    issn = {1939-3520},
    pages = {599-600},
    doi = {10.1109/TSE.1996.10007},
    publisher = {IEEE Computer Society},
    address = {Los Alamitos, CA, USA},
    month = {aug}
}

@article{Turski02,
    author = {Turski, W.M.},
    journal = {IEEE Transactions on Software Engineering},
    title = {The reference model for smooth growth of software systems revisited},
    year = {2002},
    volume = {28},
    number = {8},
    pages = {814-815},
    doi = {10.1109/TSE.2002.1027802},
    note = {Formalises the 1996 paper through positing *E* as the *incremental
        effort spent on each release*. The hypothesis is that that remains
        constant over time. E is itself presumed inversely dependent on
        *complexity*, which is in turn presumed to scale as ~s^2.}
}

@Inbook{Mens2008,
    author = {Mens, Tom},
    title = {Introduction and Roadmap: History and Challenges of Software
        Evolution},
    bookTitle = {Software Evolution},
    year = {2008},
    publisher = {Springer Berlin Heidelberg},
    address = {Berlin, Heidelberg},
    pages = {1--11},
    abstract = {The ability to evolve software rapidly and reliably is a major
        challenge for software engineering. In this introductory chapter we
        start with a historic overview of the research domain of software
        evolution. Next, we briefly introduce the important research themes in
        software evolution, and identify research challenges for the years to
        come. Finally, we provide a roadmap of the topics treated in this book,
    and explain how the various chapters are related.},
    isbn = {978-3-540-76440-3},
    doi = {10.1007/978-3-540-76440-3_1},
    url = {https://doi.org/10.1007/978-3-540-76440-3_1},
    note = {A good reference for the point that most considerations of software
        development and evolution have focussed on individual pieces of
            software, and not on collective properties.}
}

@article{mapping-repos-2021,
    author = {Sayago-Heredia, Jaime and Pérez-Castillo, Ricardo and Piattini,
        Mario},
    title = {A Systematic Mapping Study on Analysis of Code Repositories},
    journal = {Informatica},
    year = {2021},
    doi = {10.15388/21-INFOR454},
    abstract = {Code repositories contain valuable information, which can be
        extracted, processed and synthesized into valuable information. It
            enabled developers to improve maintenance, increase code quality and
            understand software evolution, among other insights. Certain
            research has been made during the last years in this field. This
            paper presents a systematic mapping study to find, evaluate and
            investigate the mechanisms, methods and techniques used for the
            analysis of information from code repositories that allow the
            understanding of the evolution of software. Through this mapping
            study, we have identified the main information used as input for the
            analysis of code repositories (commit data and source code), as well
            as the most common methods and techniques of analysis
            (empirical/experimental and automatic). We believe the conducted
            research is useful for developers working on software development
            projects and seeking to improve maintenance and understand the
            evolution of software through the use and analysis of code
            repositories.},
    volume = {32},
    number = {3},
    pages = {619-660},
    note = {"Systematic Mapping" there just means elucidating the general
        fields of around 200 papers on mining or analysing code repos. One of
            their resultant categories is "statistics", which encompasses
            statistical analyses of code. For that category, they ultimately
            identify 7 potentially relevant papers.}
}

@inproceedings{non-code-artifacts-2014, 
    author = {Bigliardi, Luca and Lanza, Michele and Bacchelli, Alberto and
        D'Ambros, Marco and Mocci, Andrea}, 
    booktitle = {14th International Conference on Quality Software},
    title = {Quantitatively Exploring Non-code Software Artifacts},
    year = {2014},
    volume = {},
    number = {},
    pages = {286-295},
    doi = {10.1109/QSIC.2014.31}
}

@article{macro-evolution-2009,
    author = {Gonzalez-Barahona, Jesus M. and Robles, Gregorio and Michlmayr,
        Martin and Amor, Juan José and German, Daniel M.},
    year = {2009},
    date = {2009/06/01},
    title = {Macro-level software evolution: a case study of a large software
        compilation},
    journal = {Empirical Software Engineering},
    pages = {262-285},
    volume = {14},
    issue = {3},
    abstract = {Software evolution studies have traditionally focused on
        individual products. In this study we scale up the idea of software
            evolution by considering software compilations composed of a large
            quantity of independently developed products, engineered to work
            together. With the success of libre (free, open source) software,
        these compilations have become common in the form of ‘software
            distributions’, which group hundreds or thousands of software
            applications and libraries into an integrated system. We have
            performed an exploratory case study on one of them, Debian
            GNU/Linux, finding some significant results. First, Debian has been
            doubling in size every 2 years, totalling about 300 million lines of
            code as of 2007. Second, the mean size of packages has remained
            stable over time. Third, the number of dependencies between packages
            has been growing quickly. Finally, while C is still by far the most
            commonly used programming language for applications, use of the C++,
        Java, and Python languages have all significantly increased. The study
            helps not only to understand the evolution of Debian, but also
            yields insights into the evolution of mature libre software systems
            in general.},
    url = {https://doi.org/10.1007/s10664-008-9100-x},
    doi = {10.1007/s10664-008-9100-x},
    note = {A study of the (entire) Debian/GNU system, with the following
        "significant results":

        "First, Debian has been doubling in size every 2 years, totalling about
        300 million lines of code as of 2007. Second, the mean size of
        packages has remained stable over time. Third, the number of
        dependencies between packages has been growing quickly."

        They provide a usual distinction of package sizes betwen:

        "very small (less than one thousand lines of code), small (between one
        and ten thousand lines) and medium-sized (between ten and fifty
        thousand lines of code"

        "large" packages are then over 100,000 LOC, for which sizes increased
        over time, a phenomenon they claim reflects Lehman's sixth "law" of
        software evolution.

        "Perhaps the most significant fact is that the average size of packages
        is relatively stable, around 30 KSLOC for Debian 4.0 and 23 KSLOC for
        other releases, see Table 1. Currently, we lack an authoritative
        explanation for this phenomenon, but we have several hypotheses. One
        of them is that libre software production tends to grow mainly by
        creating new, more specialized, smaller packages (that can be
        developed by a handful of developers), rather than large, complex
        ones (that require a large software development team).
        With time, some of the most successful small packages may attract more
        interest and developers, and start to grow. Perhaps the total mixture
        in Debian is so rich that while many packages grow in size, smaller
        ones are included causing the average to stay approximately constant."

        Mean file sizes differ between languages, but tend to stay stable over
        time within any one language.}
}

@inproceedings{mining-repos-2013, 
    author = {Allamanis, Miltiadis and Sutton, Charles},
    booktitle = {2013 10th Working Conference on Mining Software Repositories},
    title = {Mining source code repositories at massive scale using language
        modeling},
    year = {2013},
    volume = {},
    number = {},
    pages = {207-216},
    doi = {10.1109/MSR.2013.6624029},
    note = {"we build the first giga-token probabilistic language model of
        source code, based on 352 million lines of Java."

        These lines are drawn from 14,807 individual projects from GitHub. More
        generally,

        "our approach ... [enables] new complexity metrics based on statistical
        analysis of large corpora. We call these metrics data-driven complexity
        metrics."

        They find that *original identifiers* increase at roughly 56 per kLOC,
        and that most of these are variable names. They develop an n-gram model
        to assess predicability of language tokens. This is used to estimate
        probabilities of n-grams and so to provide *data-driven complexity
        metrics*, in particular an *n-gram log probability*, in place of
        "simpler" metrics such as LOC and cyclocomplexity.

        It's a great project that goes well beyond what I'll be doing with
        pkgstats!}
}

@inproceedings{github-populatiry-2016,
    author = {Borges, Hudson and Hora, Andre and Valente, Marco Tulio},
    title = {Predicting the Popularity of GitHub Repositories},
    year = {2016},
    isbn = {9781450347723},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2972958.2972966},
    doi = {10.1145/2972958.2972966},
    abstract = {GitHub is the largest source code repository in the world. It
        provides a git-based source code management platform and also many
            features inspired by social networks. For example, GitHub users can
            show appreciation to projects by adding stars to them. Therefore,
        the number of stars of a repository is a direct measure of its
            popularity. In this paper, we use multiple linear regressions to
            predict the number of stars of GitHub repositories. These
            predictions are useful both to repository owners and clients, who
            usually want to know how their projects are performing in a
            competitive open source development market. In a large-scale
            analysis, we show that the proposed models start to provide accurate
            predictions after being trained with the number of stars received in
            the last six months. Furthermore, specific models---generated using
            data from repositories that share the same growth trends---are
            recommended for repositories with slow growth and/or for
            repositories with less stars. Finally, we evaluate the ability to
            predict not the number of stars of a repository but its rank among
            the GitHub repositories. We found a very strong correlation between
            predicted and real rankings (Spearman's rho greater than 0.95).},
    booktitle = {Proceedings of the The 12th International Conference on
        Predictive Models and Data Analytics in Software Engineering},
    articleno = {9},
    numpages = {10},
    keywords = {Prediction Models, Open Source Development, Social Coding,
        GitHub, Popularity},
    location = {Ciudad Real, Spain},
    series = {PROMISE 2016},
    note = {just about predicting future stars from temporal patterns of prior
        stars, so not relevant at all. (And in fact should never have arisen as
                a candidate in Sayago & Heredia's original study.)}

}

@inproceedings{gh-snippets-2017,
    author={Yang, Di and Martins, Pedro and Saini, Vaibhav and Lopes, Cristina},
    booktitle={2017 IEEE/ACM 14th International Conference on Mining Software
        Repositories (MSR)},
    title={Stack Overflow in Github: Any Snippets There?},
    year={2017},
    volume={},
    number={},
    pages={280-290},
    doi={10.1109/MSR.2017.13},
    note = {just to show that code snippets get copied-and-pasted between
        projects, along with Abdalkareem & others (2017)}
}

@article{so-snippets-2017,
    title = {On code reuse from StackOverflow: An exploratory study on Android apps},
    journal = {Information and Software Technology},
    volume = {88},
    pages = {148-158},
    year = {2017},
    issn = {0950-5849},
    doi = {https://doi.org/10.1016/j.infsof.2017.04.005},
    url = {https://www.sciencedirect.com/science/article/pii/S0950584917303610},
    author = {Rabe Abdalkareem and Emad Shihab and Juergen Rilling}
}

@article{code-review-2018,
    author = {Pascarella, Luca and Spadini, Davide and Palomba, Fabio and
        Bruntink, Magiel and Bacchelli, Alberto},
    title = {Information Needs in Contemporary Code Review},
    year = {2018},
    issue_date = {November 2018},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {2},
    number = {CSCW},
    url = {https://doi.org/10.1145/3274404},
    doi = {10.1145/3274404},
    abstract = {Contemporary code review is a widespread practice used by
        software engineers to maintain high software quality and share project
            knowledge. However, conducting proper code review takes time and
            developers often have limited time for review. In this paper, we aim
            at investigating the information that reviewers need to conduct a
            proper code review, to better understand this process and how
            research and tool support can make developers become more effective
            and efficient reviewers. Previous work has provided evidence that a
            successful code review process is one in which reviewers and authors
            actively participate and collaborate. In these cases, the threads of
            discussions that are saved by code review tools are a precious
            source of information that can be later exploited for research and
            practice. In this paper, we focus on this source of information as a
            way to gather reliable data on the aforementioned reviewers' needs.
            We manually analyze 900 code review comments from three large
            open-source projects and organize them in categories by means of a
            card sort. Our results highlight the presence of seven high-level
            information needs, such as knowing the uses of methods and variables
            declared/modified in the code under review. Based on these results
            we suggest ways in which future code review tools can better support
            collaboration and the reviewing task.},
    journal = {Proc. ACM Hum.-Comput. Interact.},
    month = {nov},
    articleno = {135},
    numpages = {27},
    keywords = {code review, mining software repositories, information needs},
    note = {A really detailed study drawn from
        https://www.gerritcodereview.com/, and interviews with lots of code
            reviewers.}
}

@inproceedings{static-analysis-2016,
    author={Papamichail, Michail and Diamantopoulos, Themistoklis and
        Symeonidis, Andreas},
    booktitle={2016 IEEE International Conference on Software Quality,
        Reliability and Security (QRS)},
    title={User-Perceived Source Code Quality Estimation Based on Static
        Analysis Metrics},
    year={2016},
    volume={},
    number={},
    pages={100-107},
    doi={10.1109/QRS.2016.22},
    note={Also in 2 other, slightly modified versions.

        Quality of code is directly related to suitability for reuse - an
        important point!

        Cites "A metrics suite for object-oriented design" (1994), which is a
        good reference for complex static metrics that can be used in specific
        circumstances (such as OOP for that paper). Metrics measure things such
        as depth and breadth of class inheritance patterns.

        Uses a comprehensive suite of metrics, including the following relevant ones:

        - cyclomatic complexity (not measured here)
        - #comments / LOC
        - "Efficient Couplings" = # types inside source file that depend on
            types defined in other files (not measured here but could easily be)
        - Other metrics related to "Afferent" and "Efferent" couplings, which
            are numbers of classes in other packages which depend on classes
            within target package (as a measure of "responsibility"), and
            numbers of type dependencies from external packages within target
            package (Efferent), 

        Nevertheless, no particularly relevant results emerge.}
}

@inproceedings{dimaridou2017towards,
    title={Towards Modeling the User-perceived Quality of Source Code using
        Static Analysis Metrics.},
    author={Dimaridou, Valasia and Kyprianidis, Alexandros-Charalampos and
        Papamichail, Michail and Diamantopoulos, Themistoklis G and Symeonidis,
        Andreas L},
    booktitle={ICSOFT},
    pages={73--84},
    year={2017}
}


@inproceedings {metric-evolution-2016,
    booktitle = {Vision, Modeling & Visualization},
    editor = {Matthias Hullin and Marc Stamminger and Tino Weinkauf},
    title = {{Metric Evolution Maps: Multidimensional Attribute-driven
        Exploration of Software Repositories}},
    author = {Silva, Renato Rodrigues Oliveira da and Vernier, Eduardo Faccin
        and Rauber, Paulo Eduardo and Comba, Joao L. D. and Minghim, Rosane and
            Telea, Alexandru C.},
    year = {2016},
    publisher = {The Eurographics Association},
    ISSN = {-},
    ISBN = {978-3-03868-025-3},
    DOI = {10.2312/vmv.20161343},
    note = {Mostly about a technique to visualise temporal evolution of metrics.
        Uses a variety of external static analysers.}
}

@article{fuzzy-metrics-2016,
    author = {Ulutagay, Gözde and Saini, Munish and Mehmi, Sandeep and Chahal,
        Kuljit Kaur},
    year = {2016},
    date = {2016/09/14},
    title = {Understanding Open Source Software Evolution Using Fuzzy Data
        Mining Algorithm for Time Series Data},
    volume = {2016},
    url = {https://doi.org/10.1155/2016/1479692},
    doi = {10.1155/2016/1479692},
    journal = {Advances in Fuzzy Systems},
    publisher = {Hindawi Publishing Corporation},
    note = {Analyses only one piece of software, with no details of what metrics
        where actually analysed.}
}

@misc{pkg-mngrs-2018,
    title = {The evolution of package managers},
    url = {https://opensource.com/article/18/7/evolution-package-managers},
    language = {en},
    urldate = {2021-11-24},
    journal = {Opensource.com},
    date = {2018-07-26},
    author = {Ovens, Steve}
}


@misc{new-pypi-2018,
    title = {A new package index for {Python} [{LWN}.net]},
    url = {https://lwn.net/Articles/751458/},
    urldate = {2021-11-24},
    journal = {A new package index for Python},
    author = {Harihareswara, Sumana},
    date = {2018-04-11},
    year = {2018},
}


@misc{ctan-wiki,
    title = {CTAN},
    copyright = {Creative Commons Attribution-ShareAlike License},
    url = {https://en.wikipedia.org/w/index.php?title=CTAN&oldid=1049045588},
    language = {en},
    urldate = {2021-11-24},
    journal = {Wikipedia},
    month = oct,
    year = {2021},
    note = {Page Version ID: 1049045588},
}


@misc{npm-2020,
    title = {An abbreviated history of {JavaScript} package managers},
    url = {https://javascript.plainenglish.io/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e},
    abstract = {This post explains why npm, Yarn and pnpm were created and the
        other major problems they’ve solved over time.},
    language = {en},
    urldate = {2021-11-24},
    journal = {Medium},
    author = {Goldwater, Matt},
    month = feb,
    year = {2020},
}


@misc{npm-impact-2017,
    title={On the Impact of Micro-Packages: An Empirical Study of the npm
        JavaScript Ecosystem}, 
    author={Raula Gaikovina Kula and Ali Ouni and Daniel M. German
        and Katsuro Inoue},
    year={2017},
    eprint={1709.04638},
    archivePrefix={arXiv},
    primaryClass={cs.SE}
}

@inproceedings{npm-dynamics-2016,
    author = {Wittern, Erik and Suter, Philippe and Rajagopalan, Shriram},
    title = {A Look at the Dynamics of the JavaScript Package Ecosystem},
    year = {2016},
    isbn = {9781450341868},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2901739.2901743},
    doi = {10.1145/2901739.2901743},
    booktitle = {Proceedings of the 13th International Conference on Mining
        Software Repositories},
    pages = {351–361},
    numpages = {11},
    keywords = {Node.js, software ecosystem analysis, JavaScript},
    location = {Austin, Texas},
    series = {MSR '16}
}

@article{network-centrality-79,
    title = {Centrality in social networks conceptual clarification},
    journal = {Social Networks},
    volume = {1},
    number = {3},
    pages = {215-239},
    year = {1978},
    issn = {0378-8733},
    doi = {https://doi.org/10.1016/0378-8733(78)90021-7},
    url = {https://www.sciencedirect.com/science/article/pii/0378873378900217},
    author = {Linton C. Freeman}
}

@article{igraph,
    title = {The igraph software package for complex network research},
    author = {Gabor Csardi and Tamas Nepusz},
    journal = {InterJournal},
    volume = {Complex Systems},
    pages = {1695},
    year = {2006},
    url = {https://igraph.org},
}


@book{martin-agile-2002,
    title = {Agile Software Development, Principles, Patterns, and Practices},
    author = {Martin, Robert C.},
    year = {2003},
    publisher = {Prentice-Hall},
    location = {Upper Saddle River, N.J.},
    ISBN = {978-0-135-97444-5}
}

@misc{dpkg,
	title = {3. {Binary} packages — {Debian} {Policy} {Manual} v4.6.0.1},
	url = {https://www.debian.org/doc/debian-policy/ch-binary.html},
	urldate = {2022-01-13},
	journal = {Debian Policy Manual},
	author = {{Debian Policy Editors}},
	month = aug,
	year = {2021},
}

@inproceedings{almugrin_coupling_2015,
    title = {Indirect {Package} {Coupling} {Based} on {Responsibility} in an
        {Agile}, {Object}-{Oriented} {Environment}},
    doi = {10.1109/TSA.2015.26},
    abstract = {Object-oriented systems are dynamic and have to be constantly
        maintained, or they become aged and irrelevant. Poor choices made during
            design phase result in costly problems. Hence, design metrics should
            be an essential part of the agile software development process.
            Martin's metrics [1] are wellknown package design metrics that can
            be used in early stages of software development. Martin began with a
            set of object-oriented design principles and designed his metrics
            based on these principles. In [2], we began with Martin's principles
            and used them to modify his coupling, instability and abstractness
            metrics. Martin's metric suite and our previous metric suite only
            measure direct coupling. The authors believe that this limits these
            metric suites' accuracy. In this work, these suites are enhanced by
            analyzing local and global dependencies of all packages. We present
            a case study to show that the new metrics are very promising and
            lead to improved results.},
    booktitle = {2015 {Second} {International} {Conference} on {Trustworthy}
        {Systems} and {Their} {Applications}},
    author = {Almugrin, Saleh and Melton, Austin},
    month = jul,
    year = {2015},
    keywords = {abstractness, Accuracy, Couplings, indirect coupling,
        instability, maintainability, metrics, Object oriented modeling,
        responsibility, Software measurement, Software systems},
    pages = {110--119}
}


@inproceedings{decan_development_2015,
    address = {New York, NY, USA},
    series = {{ECSAW} '15},
    title = {On the {Development} and {Distribution} of {R} {Packages}: {An}
        {Empirical} {Analysis} of the {R} {Ecosystem}},
    isbn = {978-1-4503-3393-1},
    shorttitle = {On the {Development} and {Distribution} of {R} {Packages}},
    url = {https://doi.org/10.1145/2797433.2797476},
    doi = {10.1145/2797433.2797476},
    abstract = {This paper explores the ecosystem of software packages for R,
        one of the most popular environments for statistical computing today. We
            empirically study how R packages are developed and distributed on
            different repositories: CRAN, BioConductor, R-Forge and GitHub. We
            also explore the role and size of each repository, the
            inter-repository dependencies, and how these repositories grow over
            time. With this analysis, we provide a deeper insight into the
            extent and the evolution of the R package ecosystem.},
    urldate = {2022-01-25},
    booktitle = {Proceedings of the 2015 {European} {Conference} on {Software}
        {Architecture} {Workshops}},
    publisher = {Association for Computing Machinery},
    author = {Decan, Alexandre and Mens, Tom and Claes, Maelick and Grosjean,
        Philippe},
    month = sep,
    year = {2015},
    keywords = {package, R, software development, software distribution,
        software ecosystem, software repository mining},
    pages = {1--6},
}


@inproceedings{decan_when_2016,
    title = {When {GitHub} {Meets} {CRAN}: {An} {Analysis} of
        {Inter}-{Repository} {Package} {Dependency} {Problems}},
    volume = {1},
    shorttitle = {When {GitHub} {Meets} {CRAN}},
    doi = {10.1109/SANER.2016.12},
    abstract = {When developing software packages in a software ecosystem, an
        important and well-known challenge is how to deal with dependencies to
            other packages. In presence of multiple package repositories,
        dependency management tends to become even more problematic. For the R
            ecosystem of statistical computing, dependency management is
            currently insufficient to deal with multiple package versions and
            inter-repository package dependencies. We explore how the use of
            GitHub influences the R ecosystem, both for the distribution of R
            packages and for inter-repository package dependency management. We
            also discuss how these problems could be addressed.},
    booktitle = {2016 {IEEE} 23rd {International} {Conference} on {Software}
        {Analysis}, {Evolution}, and {Reengineering} ({SANER})},
    author = {Decan, Alexandre and Mens, Tom and Claes, Maëlick and Grosjean,
        Philippe},
    month = mar,
    year = {2016},
    keywords = {CRAN, Data mining, Ecosystems, Electronic mail, GitHub,
        Metadata, package dependency management, software distribution, software
            ecosystem, software evolution, Software packages, software
            repository mining, Writing}, pages = {493--504},
}


@inproceedings{german_evolution_2013,
    title = {The {Evolution} of the {R} {Software} {Ecosystem}},
    doi = {https://doi.org/10.1109/CSMR.2013.33},
    abstract = {Software ecosystems form the heart of modern companies'
        collaboration strategies with end users, open source developers and
            other companies. An ecosystem consists of a core platform and a halo
            of user contributions that provide value to a company or project. In
            order to sustain the level and number of high-quality contributions,
        it is crucial for companies and contributors to understand how
            ecosystems tend to evolve and can be maintained successfully over
            time. As a first step, this paper explores the evolution
            characteristics of the statistical computing project GNU R, which is
            a successful, end-user programming ecosystem. We find that the
            ecosystem of user-contributed R packages has been growing steadily
            since R's conception, at a significantly faster rate than core
            packages, yet each individual package remains stable in size. We
            also identified differences in the way user-contributed and core
            packages are able to attract an active community of users.},
    booktitle = {2013 17th {European} {Conference} on {Software} {Maintenance}
        and {Reengineering}},
    author = {German, Daniel M. and Adams, Bram and Hassan, Ahmed E.},
    month = mar,
    year = {2013},
    note = {ISSN: 1534-5351},
    keywords = {Communities, Companies, Documentation, Ecosystems, Electronic
        mail, Evolution, Programming, R, Software, Software ecosystems},
    pages = {243--252},
}


@article{plakidas_evolution_2017,
    title = {Evolution of the {R} software ecosystem: {Metrics}, relationships,
        and their impact on qualities},
    volume = {132},
    issn = {0164-1212},
    shorttitle = {Evolution of the {R} software ecosystem},
    url = {https://www.sciencedirect.com/science/article/pii/S0164121217301371},
    doi = {10.1016/j.jss.2017.06.095},
    abstract = {Software ecosystems are an important new concept for
        collaborative software development, and empirical studies on their
            development are important towards understanding the underlying
            dynamics and modelling their behaviour. We conducted an explorative
            analysis of the R ecosystem as an exemplar on high-level,
        ecosystem-wide assessment. Based principally on the documentation
            metadata of the R packages, we generated a variety of metrics that
            allow the quantification of the R ecosystem. We also categorized the
            ecosystem participants, both in the software marketplace and in the
            developer community, by characteristics that measure their activity
            and impact. By viewing our metrics across the ecosystem’s lifecycle
            for the various participant categories, we discovered
                interrelationships between them and determined the contribution
                    of each category to the ecosystem as a whole.},
    language = {en},
    urldate = {2022-01-25},
    journal = {Journal of Systems and Software},
    author = {Plakidas, Konstantinos and Schall, Daniel and Zdun, Uwe},
    month = oct,
    year = {2017},
    keywords = {Empirical study, Evolution, Quantitative analysis, R, Software
        ecosystems},
    pages = {119--146},
}


@inproceedings{decan_topology_2016,
    address = {New York, NY, USA},
    series = {{ECSAW} '16},
    title = {On the topology of package dependency networks: a comparison of
        three programming language ecosystems},
    isbn = {978-1-4503-4781-5},
    shorttitle = {On the topology of package dependency networks},
    url = {https://doi.org/10.1145/2993412.3003382},
    doi = {10.1145/2993412.3003382},
    abstract = {Package-based software ecosystems are composed of thousands of
        interdependent software packages. Many empirical studies have focused on
            software packages belonging to a single software ecosystem, and
            suggest to generalise the results to more ecosystems. We claim that
            such a generalisation is not always possible, because the technical
            structure of software ecosystems can be very different, even if
            these ecosystems belong to the same domain. We confirm this claim
            through a study of three big and popular package-based programming
            language ecosystems: R's CRAN archive network, Python's PyPI
            distribution, and JavaScript's NPM package manager. We study and
            compare the structure of their package dependency graphs and reveal
            some important differences that may make it difficult to generalise
            the findings of one ecosystem to another one.},
    urldate = {2022-01-25},
    booktitle = {Proccedings of the 10th {European} {Conference} on {Software}
        {Architecture} {Workshops}},
    publisher = {Association for Computing Machinery},
    author = {Decan, Alexandre and Mens, Tom and Claes, Maelick},
    month = nov,
    year = {2016},
    keywords = {component dependency graph, JavaScript, Python, R, software
        distribution, software ecosystem},
    pages = {1--4},
}


@article{hornik_too_many_R_pkgs_2012,
    title = {Are {There} {Too} {Many} {R} {Packages}?},
    volume = {41},
    issn = {1026-597X},
    url = {https://www.ajs.or.at/index.php/ajs/article/view/vol41%2C%20no1%20-%205},
    doi = {10.17713/ajs.v41i1.188},
    abstract = {The number of R extension packages available from the CRAN
        repository has tremendously grown over the past 10 years. We look at
            this phenomenon in more detail, and discuss some of its
            consequences. In particular, we argue that the statistical computing
            community needs a more common understanding of software quality, and
            better domain-specific semantic resources.},
    language = {en},
    number = {1},
    urldate = {2022-01-25},
    journal = {Austrian Journal of Statistics},
    author = {Hornik, Kurt},
    year = {2012},
    pages = {59--66},
}


@article{mora-cantallops_complex_2020,
    title = {A complex network analysis of the {Comprehensive} {R} {Archive}
        {Network} ({CRAN}) package ecosystem},
    volume = {170},
    issn = {0164-1212},
    url = {https://www.sciencedirect.com/science/article/pii/S0164121220301709},
    doi = {10.1016/j.jss.2020.110744},
    abstract = {Free and open source software package ecosystems have existed
        for a long time and are among the most sophisticated human-made systems.
            One of the oldest and most popular software package ecosystems is
                CRAN, the repository of packages of the statistical language R,
                which is also one of the most popular environments for
                    statistical computing nowadays. CRAN stores a large number
                    of packages that are updated regularly and depend on a
                    number of other packages in a complex graph of relations;
        such graph is empirically studied from the perspective of complex
            network analysis (CNA) in the current article, showing how network
            theory and measures proposed by previous work can help profiling the
            ecosystem and detecting strengths, good practices and potential
            risks in three perspectives: macroscopic properties of the ecosystem
            (structure and complexity of the network), microscopic properties of
            individual packages (represented as nodes), and modular properties
            (community detection). Results show how complex network analysis
            tools can be used to assess a package ecosystem and, in particular,
                  that of CRAN.},
    language = {en},
    urldate = {2022-01-26},
    journal = {Journal of Systems and Software},
    author = {Mora-Cantallops, Marçal and Sánchez-Alonso, Salvador and
        García-Barriocanal, Elena},
    month = dec,
    year = {2020},
    keywords = {Complex network analysis, CRAN, Package ecosystems, R},
    pages = {110744},
}


@article{syeed_evolution_2013,
    title = {Evolution of {Open} {Source} {Software} {Projects}: {A}
        {Systematic} {Literature} {Review}},
    volume = {8},
    issn = {1796-217X},
    shorttitle = {Evolution of {Open} {Source} {Software} {Projects}},
    url = {http://ojs.academypublisher.com/index.php/jsw/article/view/9913},
    doi = {10.4304/jsw.8.11.2815-2829},
    number = {11},
    urldate = {2022-01-28},
    journal = {Journal of Software},
    author = {Syeed, Mahbubul and Hammouda, Imed and Syatä, Tarja},
    month = nov,
    year = {2013},
    pages = {2815--2829},
}

@article{fortuna_evolution_2011,
    title = {Evolution of a modular software network},
    issn = {0027-8424, 1091-6490},
    url = {https://www.pnas.org/content/early/2011/11/14/1115960108},
    doi = {10.1073/pnas.1115960108},
    abstract = {“Evolution behaves like a tinkerer” (François Jacob, Science,
            1977). Software systems provide a singular opportunity to understand
        biological processes using concepts from network theory. The Debian
        GNU/Linux operating system allows us to explore the evolution of a
        complex network in a unique way. The modular design detected during its
        growth is based on the reuse of existing code in order to minimize costs
        during programming. The increase of modularity experienced by the system
        over time has not counterbalanced the increase in incompatibilities
        between software packages within modules. This negative effect is far
        from being a failure of design. A random process of package installation
        shows that the higher the modularity, the larger the fraction of
        packages working properly in a local computer. The decrease in the
        relative number of conflicts between packages from different modules
        avoids a failure in the functionality of one package spreading
        throughout the entire system. Some potential analogies with the
        evolutionary and ecological processes determining the structure of
        ecological networks of interacting species are discussed.},
    language = {en},
    urldate = {2022-01-28},
    journal = {Proceedings of the National Academy of Sciences},
    author = {Fortuna, Miguel A. and Bonachela, Juan A. and Levin, Simon A.},
    month = nov,
    year = {2011},
    pmid = {22106260},
    note = {Publisher: National Academy of Sciences Section: Biological
        Sciences},
    keywords = {community assembly, evolvability, food webs, network evolution,
        robustness},
}

@article{myers_software_2003,
    title = {Software systems as complex networks: {Structure}, function, and
        evolvability of software collaboration graphs},
    volume = {68},
    shorttitle = {Software systems as complex networks},
    url = {https://link.aps.org/doi/10.1103/PhysRevE.68.046116},
    doi = {10.1103/PhysRevE.68.046116},
    abstract = {Software systems emerge from mere keystrokes to form intricate
        functional networks connecting many collaborating modules, objects,
        classes, methods, and subroutines. Building on recent advances in the
            study of complex networks, I have examined software collaboration
            graphs contained within several open-source software systems, and
            have found them to reveal scale-free, small-world networks similar
            to those identified in other technological, sociological, and
            biological systems. I present several measures of these network
            topologies, and discuss their relationship to software engineering
            practices. I also present a simple model of software system
            evolution based on refactoring processes which captures some of the
            salient features of the observed systems. Some implications of
            object-oriented design for questions about network robustness,
        evolvability, degeneracy, and organization are discussed in the wake of
            these findings.},
    number = {4},
    urldate = {2022-01-28},
    journal = {Physical Review E},
    author = {Myers, Christopher R.},
    month = oct,
    year = {2003},
    note = {Publisher: American Physical Society},
    pages = {046116},
}

@Article{testthat,
    author = {Hadley Wickham},
    title = {testthat: Get Started with Testing},
    journal = {The R Journal},
    year = {2011},
    volume = {3},
    pages = {5--10},
    url = {https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf},
}

@Manual{roxygen2,
    title = {roxygen2: In-Line Documentation for R},
    author = {Hadley Wickham and Peter Danenberg and Gábor Csárdi and
        Manuel Eugster},
    year = {2022},
    note = {R package version 7.2.0},
    url = {https://CRAN.R-project.org/package=roxygen2},
}

@misc{wiki-code-hosting,
    author = {{Source Code Hosting}},
    title = "Comparison of source-code-hosting facilities -- {W}ikipedia{,} The Free Encyclopedia",
    year = "2022",
    url =
        "https://en.wikipedia.org/wiki/Comparison_of_source-code-hosting_facilities",
    note = "[Online; accessed 27-June-2022]"
}
